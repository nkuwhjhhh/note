# Part 5 面向对象编程(高级)

### 1. 关键字：static

**如果想让一个成员变量被类的所有实例所共享，就用static修饰即可，称为类变量（或类属性），也称为静态变量、静态方法。不需要创建对象就可以调用类方法，简化了方法的调用。**

#### 1.1 static关键字

- 使用范围：
  - 在Java类中，可用static修饰属性、方法、代码块、内部类

- 被修饰后的成员具备以下特点：
  - 随着类的加载而加载
  - 优先于对象存在
  - 修饰的成员，被所有对象所共享
  - 访问权限允许时，可不创建对象，直接被类调用



#### 1.2 静态变量

- 默认值规则和实例变量一样。
- 静态变量值是所有对象共享，存储在方法区。
- 静态变量在本类中，可以在任意方法、代码块、构造器中直接使用。
- 在其他类中可通过“`类名.静态变量`”（推荐）直接访问，也可以通过“`对象.静态变量`”的方式访问。
- 静态变量的get/set方法也静态的，当局部变量与静态变量`重名时`，使用“`类名.静态变量`”进行区分。



#### 1.3 静态方法

- 静态方法在本类的任意方法、代码块、构造器中都可以直接被调用。
- 在其他类中可通过“`类名.静态方法`”（推荐）直接访问，也可以通过“`对象.静态方法`”的方式访问。
- <font color='red'>在static方法内部只能访问类的static修饰的属性或方法，不能访问类的非static的结构</font>。
- <font color='red'>静态方法可以被子类继承，但不能被子类重写。</font>
- <font color='red'>静态方法的调用都只看编译时类型。</font>
- static方法内部不能有this，也不能有super。如果有重名问题，使用“类名.”进行区别。



### 2. 单例(Singleton)设计模式

类的单例设计模式：采取一定的方法保证在整个的软件系统中，对某个类**只能存在一个对象实例**，并且该类只提供一个取得其对象实例的方法。

#### 2.1 实现思路

将类构造器的访问权限设置为private，阻止类外产生该类对象。类内创建静态对象，用静态方法访问该静态成员变量。



#### 2.2 单例模式的两种实现方式

##### 2.2.1 饿汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }

    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single = new Singleton();

    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        return single;
    }
}

```

##### 2.2.2 懒汉式

```java
class Singleton {
    // 1.私有化构造器
    private Singleton() {
    }
    // 2.内部提供一个当前类的实例
    // 4.此实例也必须静态化
    private static Singleton single;
    // 3.提供公共的静态的方法，返回当前类的对象
    public static Singleton getInstance() {
        if(single == null) {
            single = new Singleton();
        }
        return single;
    }
}

```

##### 2.2.3 饿汉式 vs 懒汉式

- 饿汉式：立即加载，使用方便，线程安全，但易泄露，一直占据内存。
- 懒汉式：延迟加载，空间上更节省，但线程不安全，保证不了单例的唯一性。



#### 2.3 优点及应用场景

减少了`系统性能开销`，场景：Windows的Task Manager (任务管理器)，Windows的Recycle Bin (回收站)，Application等。



### 3. 理解main方法的语法

```java
public static void main(String[] args){
    //...
}
```

是普通的静态方法，也是程序入口，格式固定。

String[] args为命令行参数，可以在命令行中输入参数。

**PS**：从键盘获取数据的两种方式：使用Scanner，使用命令行。



### 4. 代码块

- 作用：对Java类或对象进行初始化
- 分类：静态代码块，非静态代码块

#### 4.1 静态代码块

在代码块的前面加static，就是静态代码块。

##### 4.1.1 特点

- 可以对类的属性、类的声明进行初始化操作。
- 不可以调用非静态的属性和方法。
- 若有多个静态的代码块，那么按照从上到下的顺序依次执行。
- 静态代码块的执行要先于非静态代码块。
- 静态代码块随着类的加载而加载，且只执行一次。



#### 4.2 非静态代码块

和构造器一样，也是用于实例变量的初始化等操作。

##### 4.2.1 意义

将多个重载的构造器的公共代码提取出来到非静态代码块中，减少冗余代码。

##### 4.2.2 特点

- 可以对类的属性、类的声明进行初始化操作。
- 除了调用非静态的结构外，还可以调用静态的变量或方法。
- 若有多个非静态的代码块，那么按照从上到下的顺序依次执行。
- 每次创建对象的时候，都会执行一次。且先于构造器执行。



#### 4.3 小结：实例变量赋值顺序

由父及子，静态先行。

![image-20240301103456491](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240301103456491.png)



### 5. final关键字

#### 5.1 使用

##### 5.1.1 final修饰类

表示这个类不能被继承，没有子类。提高安全性，提高程序的可读性。

##### 5.1.2 final修饰方法

表示这个方法不能被子类重写。

##### 5.1.3 final修饰变量

- final修饰某个变量（成员变量或局部变量），一旦赋值，它的值就不能被修改，即常量，常量名建议使用大写字母。
- 如果某个成员变量用final修饰后，没有set方法，并且必须初始化（可以显式赋值、或在初始化块赋值、实例变量还可以在构造器中赋值）
- 和static搭配修饰成员变量时被称为全局常量。



### 6. 抽象类与抽象方法(或abstract关键字)

**抽象方法**：父类在声明无法给出具体实现的方法时，只有方法签名，没有方法体。（不带花括号，直接分号）。

**抽象类**：包含抽象方法的类。

子类对父类抽象方法的实现称为**方法重写**，也称**实现方法**。

#### 6.1 使用说明

- 抽象类不能创建对象，编译无法通过。
- 抽象类是用来被继承的，**抽象类的子类必须重写父类的抽象方法**，并提供方法体。若没有重写全部的抽象方法，仍为抽象类。
- 抽象类中，**也有构造方法**，是供子类创建对象时，初始化父类成员变量使用的。
- 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。不包含抽象方法的抽象类是为了不让调用者创建该类对象。



#### 6.2 注意

- 不能用abstract修饰变量、代码块、构造器；
- 不能用abstract修饰私有方法、静态方法、final的方法、final的类。



#### 6.3 应用

模板方法的设计模式：将多态和抽象联系起来，在抽象父类中写入无法给出具体实现的抽象方法，以及能给出具体实现的模板方法（把基本操作组合到一起，子类一般不能重写），模板方法中调用抽象方法。利用多态，具体执行时，挂哪个子类，就执行哪个子类的实现代码。



### 7. 接口(interface)

继承是is a，接口是has a。

#### 7.1 定义格式

与定义类方式相似，但是使用 `interface` 关键字。但不是类，是另外一种引用数据类型。

> 引用数据类型：数组，类，枚举，接口，注解。

```java
[修饰符] interface 接口名{
    //接口的成员列表：
    // 公共的静态常量：public static final可以省略
    // 公共的抽象方法：public abstract可以省略
    
    // 公共的默认方法（JDK1.8以上）：default不能省略，有方法体，可以被实现类调用，也可以在实现类中重写，默认调用重写的
    // 公共的静态方法（JDK1.8以上）：static不能省略，有方法体，但只能被接口调用，不可被其实现类调用
    // 私有方法（JDK1.9以上）
    
    // 没有构造器，没有初始化块，因为接口中没有成员变量需要动态初始化。
}
```



#### 7.2 接口的使用规则

##### 7.2.1 类实现接口（implements）

```java
【修饰符】 class 实现类  implements 接口{
	// 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}

【修饰符】 class 实现类 extends 父类 implements 接口{
    // 重写接口中抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```

- 如果接口的实现类是非抽象类，那么必须`重写接口中所有抽象方法`。

- 默认方法可以选择保留，也可以重写。

  > 重写时，default单词就不要再写了，它只用于在接口中表示默认方法，到类中就没有默认方法的概念了

- 接口中的静态方法不能被继承也不能被重写



##### 7.2.2 接口的多实现（implements）

一个类能继承一个父类，同时实现多个接口，叫做接口的`多实现`。

```java
【修饰符】 class 实现类  implements 接口1，接口2，接口3。。。{
	// 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}

【修饰符】 class 实现类 extends 父类 implements 接口1，接口2，接口3。。。{
    // 重写接口中所有抽象方法【必须】，当然如果实现类是抽象类，那么可以不重写
  	// 重写接口中默认方法【可选】
}
```

> 接口中，有多个抽象方法时，实现类必须重写所有抽象方法。**如果抽象方法有重名的，只需要重写一次**。



##### 7.2.3 接口的多继承(extends)

一个接口能继承另一个或者多个接口，接口的继承也使用 `extends` 关键字，子接口继承父接口的方法。

- 所有父接口的抽象方法都有重写。
- 方法签名相同的抽象方法只需要实现一次。



##### 7.2.4 接口与实现类对象构成多态引用

通过接口类型的变量调用方法，最终执行的是你new的实现类对象实现的方法体。

```java
public class Mouse implements USB3{}
public class KeyBoard implements USB3{}
USB3 usb = new Mouse();// 多态引用
```



##### 7.2.5 使用接口的静态成员

- 通过“接口名.”调用接口的静态方法，**不能通过实现类的对象进行调用**
- 通过“接口名.”直接使用接口的静态常量



##### 7.2.6 使用接口的非静态方法

- 对于接口的抽象方法、默认方法，**只能通过实现类对象才可以调用**。如果实现类重写了就执行重写的默认方法，如果没有重写，就执行接口中的默认方法
- 接口不能直接创建对象，只能创建实现类的对象



#### 7.3 JDK8中相关冲突问题

##### 7.3.1 默认方法冲突

**（1）类优先原则**

当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的抽象方法重名，子类就近选择执行父类的成员方法。

不重写默认调用父类的。可以通过`接口.super.默认方法`调用接口中的。

**（2）接口冲突（左右为难）**

一个类实现多个接口，并且接口中有重名的默认方法。

需要选择保留一个，重写时通过`接口名.super.方法名`的方法选择保留哪个接口的默认方法。也可以完全重写。



##### 7.3.2 常量冲突问题

父类和父接口，或父接口和另一个父接口中存在相同同名常量。

用`super.`，`接口名.`区分。



**面试题**

**1、为什么接口中只能声明公共的静态的常量？**

因为接口是标准规范，那么在规范中需要声明一些底线边界值，当实现者在实现这些规范时，不能去随意修改和触碰这些底线，否则就有“危险”。

**2、为什么JDK8.0 之后允许接口定义静态方法和默认方法呢？它违反了接口作为一个抽象标准定义的概念。**

`静态方法`：因为之前的标准类库设计中，有很多Collection/Collections或者Path/Paths这样成对的接口和类，后面的类中都是静态方法，而这些静态方法都是为前面的接口服务的，那么这样设计一对API，不如把静态方法直接定义到接口中使用和维护更方便。

`默认方法`：接口中某些抽象方法的在实现类中的实现代码相同，设计为默认方法更合适；若想在已有的老版接口中提供新方法，若添加抽象方法，则之前的已经实现该接口的类会报错。

**3、为什么JDK1.9要允许接口定义私有方法呢？我们说接口是规范，规范是需要公开让大家遵守的。**

**私有方法**：将默认方法和静态方法中共同的部分抽取出来，放在方法中，又仅限在接口内部使用，所以就增加了私有方法。



#### 7.4 接口与抽象类之间的对比

![image-20240301150921763](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240301150921763.png)



### 8. 内部类（InnerClass)

将一个类A定义在另一个类B里面，里面的那个类A就称为`内部类（InnerClass）`，类B则称为`外部类（OuterClass）`。

**存在意义**：某些类（内部类）只对某个外部事物（外部类）服务，高内聚，低耦合。

#### 8.1 分类

- 成员内部类
  - 静态成员内部类：不使用外部类的非静态成员
  - 非静态成员内部类：反之
- 局部内部类
  - 非匿名局部内部类
  - 匿名局部内部类



#### 8.2 成员内部类

- 外部类只有两种权限修饰符，成员内部类有四种。
- 可以调用外部类的结构。
- 可以直接使用外部类的所有成员，包括私有的数据。
- 可以声明为static，即静态成员内部类。
- 可以在内部定义属性、方法、构造器等结构。
- 可以继承自己的想要继承的父类，实现自己想要实现的父接口们，和外部类的父类和父接口无关。
- 可以声明为abstract类 ，被其它的内部类继承。
- 可以声明为final的，表示不能被继承。
- 编译以后生成OuterClass$InnerClass.class字节码文件（也适用于局部内部类）。
- 当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的。
- 外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式。

**格式**

- 实例化静态内部类

```
外部类名.静态内部类名 变量 = 外部类名.静态内部类名();
变量.非静态方法();
```

- 实例化非静态内部类

```
外部类名 变量1 = new 外部类();
外部类名.非静态内部类名 变量2 = 变量1.new 非静态内部类名();
变量2.非静态方法();
```



#### 8.3 局部内部类

##### 8.3.1 非匿名局部内部类

**格式**

```java
[修饰符] class 外部类{
    [修饰符] 返回值类型  方法名(形参列表){
            [final/abstract] class 内部类{
    	}
    }    
}
```

- 不能有权限修饰符
- 有作用域

```java
public void outTest(){
    class Inner{
        public void inMethod1(){
            System.out.println("Inner.inMethod1");
        }
    }

    Inner in = new Inner();
    in.inMethod1();
}
```



##### 8.3.2 匿名内部类

**格式**

```java
new 父类([实参列表]){
    重写方法...
}
```

```java
new 父接口(){
    重写方法...
}
```

- 使用场景：提供实现某个接口的类

举例1：使用匿名内部类的对象直接调用方法：

```java
interface A{
	void a();
}
public class Test{
    public static void main(String[] args){
    	new A(){
			@Override
			public void a() {
				System.out.println("aaaa");
			}
    	}.a();
    }
}
```

举例2：通过父类或父接口的变量多态引用匿名内部类的对象

```java
interface A{
	void a();
}
public class Test{
    public static void main(String[] args){
    	A obj = new A(){
			@Override
			public void a() {
				System.out.println("aaaa");
			}
    	};
    	obj.a();
    }
}
```

举例3：匿名内部类的对象作为实参

```java
interface A{
	void method();
}
public class Test{
    public static void test(A a){
    	a.method();
    }
    
    public static void main(String[] args){
    	test(new A(){

			@Override
			public void method() {
				System.out.println("aaaa");
			}
    	});
    }   
}
```



### 9. 枚举类

- **若枚举只有一个对象, 则可以作为一种单例模式的实现方式。**

##### 9.1 定义方式

- JDK5.0 之前

  - 私有化类的构造器
  - 若在类内部创建枚举类的实例，则声明为：`public static final` 
  - 若对象有实例变量，则建议声明为`private final`。

- JDK5.0 之后

  - 格式

    ```java
    【修饰符】 enum 枚举类名{
        常量对象列表
    }
    
    【修饰符】 enum 枚举类名{
        常量对象列表;
        
        对象的实例变量列表;
    }
    ```

  - 举类的常量对象列表必须在枚举类的首行，因为是常量，所以建议大写。

  -  列出的实例系统会自动添加 public static final 修饰。

  - 编译器给枚举类默认提供的是private的无参构造，如果枚举类需要的是无参构造，就不需要声明，写常量对象列表时也不用加参数。

  - 如果枚举类需要的是有参构造，需要手动定义，有参构造的private可以省略，调用有参构造的方法就是在常量对象名后面加(实参列表)就可以。

  - 枚举类默认继承的是java.lang.Enum类，因此不能再继承其他的类型。

  - JDK5.0 之后switch，提供支持枚举类型，case后面可以写枚举常量名，无需添加枚举类作为限定。

> 经验之谈：
>
> 开发中，当需要定义一组常量时，强烈建议使用枚举类。



##### 9.2 enum中常用方法

- String toString(): 默认返回的是常量名（对象名），可以继续手动重写该方法
- static 枚举类型[] values():返回枚举类型的对象数组。该方法可以很方便地遍历所有的枚举值，是一个静态方法
- static 枚举类型 valueOf(String name)：可以把一个字符串转为对应的枚举类对象。要求字符串必须是枚举类对象的“名字”。如不是，会有运行时异常：IllegalArgumentException。
- String name():得到当前枚举常量的名称。
- int ordinal():返回当前枚举常量的次序号，默认从0开始



##### 9.3 实现接口的枚举类

- 和普通 Java 类一样，枚举类可以实现一个或多个接口，但要求必须实现里面所有的抽象方法！
- 若每个枚举值在调用实现的接口方法呈现相同的行为方式，则只要统一实现该方法即可。
- 若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式，则可以让每个枚举值分别来实现该方法。

```java
//1、统一实现
enum A implements 接口1，接口2{
	//抽象方法的实现
}

//2、分别实现
enum A implements 接口1，接口2{
    // 这里的常数名和参数是调用构造器的。
    常量名1(参数){
        //抽象方法的实现或重写
    },
    常量名2(参数){
        //抽象方法的实现或重写
    },
    //...
}
```



### 10. 注解(Annotation)

注解（Annotation）是从`JDK5.0`开始引入，以“`@注解名`”在代码中存在。例如：`@Override`，`@Deprecated`，`@SuppressWarnings(value=”unchecked”)`

Annotation 可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明。还可以添加一些参数值，这些信息被保存在 Annotation 的 “name=value” 对中。

注解可以在类编译、运行时进行加载，体现不同的功能。

注解是可以被编译器或其他程序读取的。

在`JavaEE/Android中注解占据了更重要的角色`，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的`繁冗代码`和`XML配置`等。

`注解是一种趋势`，一定程度上可以说：`框架 = 注解 + 反射 + 设计模式`。

#### 10.1 常见的Annotation作用

**示例1：生成文档相关的注解**

```java
@author 标明开发该类模块的作者，多个作者之间使用,分割
@version 标明该类模块的版本
@see 参考转向，也就是相关主题
@since 从哪个版本开始增加的
@param 对方法中某参数的说明，如果没有参数就不能写
@return 对方法返回值的说明，如果方法的返回值类型是void就不能写
@exception 对方法可能抛出的异常进行说明 ，如果方法没有用throws显式抛出的异常就不能写
```

**示例2：在编译时进行格式检查(JDK内置的三个基本注解)**

`@Override`: 限定重写父类方法，该注解只能用于方法

`@Deprecated`: 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择

`@SuppressWarnings`: 抑制编译器警告

- 可以指定的警告类型有（了解）

  - all，抑制所有警告

  - unchecked，抑制与未检查的作业相关的警告

  - unused，抑制与未用的程式码及停用的程式码相关的警告

  - deprecation，抑制与淘汰的相关警告

  - nls，抑制与非 nls 字串文字相关的警告

  - null，抑制与空值分析相关的警告

  - rawtypes，抑制与使用 raw 类型相关的警告

  - static-access，抑制与静态存取不正确相关的警告

  - static-method，抑制与可能宣告为 static 的方法相关的警告

  - super，抑制与置换方法相关但不含 super 呼叫的警告

  - ...

**示例3：跟踪代码依赖性，实现替代配置文件功能**

- Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署。
- Spring框架中关于“事务”的管理



#### 10.2 元注解

`import java.lang.annotation.*;`

（1）**@Target：**用于描述注解的使用范围

* 可以通过枚举类型ElementType的10个常量对象来指定
* TYPE，METHOD，CONSTRUCTOR，PACKAGE.....

（2）**@Retention：**用于描述注解的生命周期

* 可以通过枚举类型RetentionPolicy的3个常量对象来指定
* SOURCE（源代码）、CLASS（字节码）、RUNTIME（运行时）
* `唯有RUNTIME阶段才能被反射读取到`。

（3）**@Documented**：表明这个注解应该被 javadoc工具记录。

（4）**@Inherited：**允许子类继承父类中的注解



#### 10.3 自定义注解的使用

一个完整的注解应该包含三个部分：
（1）声明
（2）使用
（3）读取

```java
【元注解】
【修饰符】 @interface 注解名{
    【成员列表】
}
```

- **元注解**：自定义注解可以通过四个元注解@Retention,@Target，@Inherited,@Documented，分别说明它的声明周期，使用位置，是否被继承，是否被生成到API文档中。
- Annotation 的成员在 Annotation 定义中以无参数有返回值的抽象方法的形式来声明，我们又称为配置参数。返回值类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型、以上所有类型的数组
- 可以使用 default 关键字为抽象方法指定默认返回值
- 如果定义的注解含有抽象方法，那么使用时必须指定返回值，除非它有默认值。格式是“方法名 = 返回值”，如果只有一个抽象方法需要赋值，且方法名为value，可以省略“value=”，所以如果注解只有一个抽象方法成员，建议使用方法名value。



##### 10.3.1 读取和处理自定义注解

自定义注解必须配上注解的信息处理流程才有意义。

我们自己定义的注解，只能使用反射的代码读取。所以自定义注解的声明周期必须是RetentionPolicy.RUNTIME。

具体的使用见`《尚硅谷_宋红康_第17章_反射机制.md》`。



#### 10.4 单元测试

JUnit4版本，要求@Test标记的方法必须满足如下要求：

- 所在的类必须是public的，非抽象的，包含唯一的无参构造器。
- @Test标记的方法本身必须是public，非抽象的，非静态的，void无返回值，()无参数的。

默认情况下，在单元测试方法中使用Scanner时，并不能实现控制台数据的输入。需要做一些设置。还可以定义test测试方法模板。



### 11. 包装类

为了让基本数据类型也能使用只针对对象设计的API或新特性，比如泛型。

![image-20240301173539383](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240301173539383.png)

还可以自定义包装类。

#### 11.1 包装类与基本数据类型间的转换

##### 11.1.1 装箱

基本数值---->包装对象

```java
// 方式一：
Integer obj1 = new Integer(4);//使用构造函数函数
// 方式二：
Integer obj2 = Integer.valueOf(4);//使用包装类中的valueOf方法
```

##### 11.1.2 拆箱

包装对象---->基本数值

```java
Integer obj = new Integer(4);
int num1 = obj.intValue();
```

##### 11.1.3 自动装箱与拆箱

只能在和自己对应的类型之间自动装箱拆箱。

```java
Integer i = 4;//自动装箱。相当于Integer i = Integer.valueOf(4);
i = i + 5;//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5;
//加法运算完成后，再次装箱，把基本数值转成对象。
```



#### 11.2 基本数据类型、包装类与字符串间的转换

**（1）基本数据类型转为字符串**

**方式1：**调用字符串重载的valueOf()方法

```java
int a = 10;
String str = String.valueOf(a);
```

**方式2：**更直接的方式

```java
int a = 10;
String str = a + "";
```

**（2）字符串转为基本数据类型**

**方式1**：字符串直接转为基本数据类型

```java
public static int parseInt(String s)
public static long parseLong(String s)
public static double parseDouble(String s)
```

**方式2**：字符串转为包装类，再自动拆箱

```java
public static Integer valueOf(String s)
public static Long valueOf(String s)
public static Double valueOf(String s)
```

**方式3：**通过包装类的构造器实现

```java
// 类似方式1：此处是调用类的静态方法parseInt等实现的。
int a = Integer.parseInt("整数的字符串");
double d = Double.parseDouble("小数的字符串");
boolean b = Boolean.parseBoolean("true或false");

// 类似方式2
int a = Integer.valueOf("整数的字符串");
double d = Double.valueOf("小数的字符串");
boolean b = Boolean.valueOf("true或false");
```

![image-20240301174411505](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240301174411505.png)

#### 11.3 包装类的其它API

##### 11.3.1 数据类型的最大最小值

```java
Integer.MAX_VALUE和Integer.MIN_VALUE
Long.MAX_VALUE和Long.MIN_VALUE
Double.MAX_VALUE和Double.MIN_VALUE
```

##### 11.3.2 字符转大小写

```java
Character.toUpperCase('x');
Character.toLowerCase('X');
```

##### 11.3.3 整数转进制

```java
Integer.toBinaryString(int i) 
Integer.toHexString(int i)
Integer.toOctalString(int i)
```

##### 11.3.4 比较的方法

```java
Double.compare(double d1, double d2)
Integer.compare(int x, int y) 
```



#### 11.4 包装类对象的特点

##### 11.4.1 包装类缓存对象

| 包装类    | 缓存对象    |
| --------- | ----------- |
| Byte      | -128~127    |
| Short     | -128~127    |
| Integer   | -128~127    |
| Long      | -128~127    |
| Float     | 没有        |
| Double    | 没有        |
| Character | 0~127       |
| Boolean   | true和false |

在此范围内，只要不new就是引用的缓冲常量对象，在方法区。



#### 11.5 类型转换问题

包装类和基本数据类型进行大小判断，先自动拆箱，再按基本数据类型进行比较。如果两个类型不同的包装类进行==比较，则直接因为类型不匹配而报错。



#### 11.6 练习

```java
Object o1 = true ? new Integer(1) : new Double(2.0);
System.out.println(o1);//1.0
// 三目运算符要求 表达式2 和 表达式3 类型一致
```

