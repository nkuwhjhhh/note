# Part 4 面向对象编程(进阶)

### 1. 关键字：this

#### 1.1 使用场景

##### 1.1.1 实例方法或构造器中使用当前对象的成员

用this来区分成员变量和局部变量。使用this访问属性和方法时，如果在本类中未找到，会从父类中查找。

##### 1.1.2 同一个类中构造器互相调用

```java
this()：调用本类的无参构造器
this(实参列表)：调用本类的有参构造器
```

规则：不能出现递归调用，只能出现一次，只能在首行。

```java
// 无参构造
public Student() {
    // this("",18);//调用本类有参构造器
}

// 有参构造
public Student(String name) {
    this();//调用本类无参构造器
    this.name = name;
}
// 有参构造
public Student(String name,int age){
    this(name);//调用本类中有一个String参数的构造器
    this.age = age;
}
```



### 2. 面向对象特征二：继承(Inheritance)

#### 2.1 好处

- 继承的出现减少了代码冗余，提高了代码的复用性。

- 继承的出现，更有利于功能的扩展。

- 继承的出现让类与类之间产生了`is-a`的关系，为多态的使用提供了前提。
  - 继承描述事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用、更一般，子类更具体。

#### 2.2 语法

```java
[修饰符] class 类A {
	...
}

[修饰符] class 类B extends 类A {
	...
}
// 类B，称为子类、派生类(derived class)、SubClass
// 类A，称为父类、超类、基类(base class)、SuperClass
```



#### 2.3 细节说明

1. 子类会继承父类所有的实例变量和实例方法
   1. 内存分配：子类和父类的实例变量都要分配内存，调用方法从子类开始从下往上找，若到根父类都没找到，则报错。
2. 子类会继承父类中私有的(private)的成员变量和方法，但不能直接访问，可通过继承的get/set方法进行访问。
3. 继承的关键字用的是“extends”，即子类不是父类的子集，而是对父类的“扩展”。
4. 子类和父类是一种相对的概念，有多层继承，但不支持多重继承，即不可同时直接继承多个父类。
5. 顶层父类是Object类。所有的类默认继承Object，作为父类。



#### 2.4 方法的重写

子类对从父类中继承来的方法进行改造，称为重写（重置、覆盖）。

> @Override：显式说明是重写，用来检测是不是满足重写方法的要求，可省略。

##### 2.4.1 方法重写的要求

1. 方法名称和参数列表相同。
2. 返回值类型：子类不可大于父类，即更具体，返回值类型为基本数据类型和void时，必须相同。
3. 访问权限：子类不可小于父类。（public > protected > 缺省 > private）（父类私有方法不可重写，跨包的父类缺省的方法也不能重写）
4. 抛出异常：子类不能大于父类，即更具体。
5. 要求子类父类中的重写方法同时为非static。若同时为static，不称为重写。因为static方法是属于类的，子类无法覆盖父类的方法。



##### 2.4.2 重载VS重写



### 3. 再谈封装性中的4种权限修饰

1. 外部类要跨包使用必须是public，否则仅限于本包使用。
2. 外部类的权限修饰符如果缺省，本包使用没问题，跨包使用有问题，即跨包仅限于子类中可见。
3. 本包下使用可以是public、protected、缺省。跨包下使用要求严格。
4. 跨包使用时，如果类的权限修饰符缺省，成员权限修饰符>类的权限修饰符也没有意义。



### 4. 关键字：super

- 子类调用父类的**属性**，**成员方法**，**构造器**。
- 出现同名，用super表明调用父类中的成员。
- super追溯不仅限于直接父类。
- this VS super：用法相似，this代表本类对象的引用，super代表父类的内存空间的标识。

#### 4.1 使用场景

前提：权限修饰符允许

##### 4.1.1 方法

- 子类未重写父类，可省略super，直接调用
- 子类重写父类，super不可省

| 关键字          | 寻找                                       |
| --------------- | ------------------------------------------ |
| 没有super和this | 先从子类匹配，一直往上找，至匹配成功       |
| 有this          | 先从子类匹配，一直往上找，至匹配成功       |
| 有super         | 从当前子类的直接父类开始往上找，至匹配成功 |

##### 4.1.2 成员变量

- 未重名，可省略，可加this，可加super
- 出现重名时，默认访问自己的，有super则访问父类的。

| 关键字          | 寻找                                   |
| --------------- | -------------------------------------- |
| 没有super和this | 局部变量→本类成员变量→父类成员变量→... |
| 有this          | 本类成员变量→父类成员变量→...          |
| 有super         | 父类成员变量→...                       |
| 总结            | 起点不同，就近原则                     |

**<font color='red'>特别说明：应该避免子类声明和父类重名的成员变量</font>**

##### 4.1.3 构造器

1. 子类不会继承父类的构造器。子类构造器通过“super(形参列表)”的方式中调用父类构造器，必须声明在构造器的首行。
2. "this(形参列表)"调用本类中重载的构造器，因此在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
3. 没有显式的"this(形参列表)" 和 "super(形参列表)"，则默认调用"super()"，即调用父类中空参的构造器。
4. 子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。
5. 一个类中声明有n个构造器，最多有n-1个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。

**<font color='red'>如果子类构造器中既未显式调用父类或本类的构造器，且父类中又没有空参的构造器，则`编译出错`。</font>**



### 5. 小结this和super

**1、this和super的意义**

this：当前对象，在构造器和非静态代码块中，表示正在new的对象；在实例方法中，表示调用当前方法的对象

super：引用父类声明的成员

**2、this和super的使用格式**

- this
  - this.成员变量：表示当前对象的某个成员变量，而不是局部变量
  - this.成员方法：表示当前对象的某个成员方法，完全可以省略this.
  - this()或this(实参列表)：调用另一个构造器协助当前对象的实例化，只能在构造器首行，只会找本类的构造器，找不到就报错
- super
  - super.成员变量：表示当前对象的某个成员变量，该成员变量在父类中声明的
  - super.成员方法：表示当前对象的某个成员方法，该成员方法在父类中声明的
  - super()或super(实参列表)：调用父类的构造器协助当前对象的实例化，只能在构造器首行，只会找直接父类的对应构造器，找不到就报错



### 6. 面向对象特征三：多态性

对象的多态性：父类的引用指向子类的对象

```java
父类类型 变量名 = 子类对象；
```

表面上是父类，实际上是子类。子类的对象可以替代父类的对象使用。一个引用类型变量可能指向(引用)多种不同类型的对象。

#### 6.1 对多态的理解

- 编译时类型：由变量使用的类型决定，“看父类”。只能调用父类声明的方法，不能调用子类扩展的方法。
- 运行时类型：由实际赋给该变量的对象决定，“看子类”。如果子类重写了方法，一定是执行子类重写的方法体。

**编译时，看左边；运行时，看右边。**

若编译时类型和运行时类型不一致，就出现了对象的多态性(Polymorphism)。

多态的使用前提：① 类的继承关系  ② 方法的重写



#### 6.2 多态的体现

1. 方法内**局部变量的赋值**体现多态
2. 方法的**形参声明**体现多态：形参是父类类型，实参是子类对象
3. 方法**返回值类型**体现多态：返回值类型是父类类型，实际返回的是子类对象



#### 6.3 多态的用处

无法确定运行时的具体类型，只能确定是某个系列的类型，比如宠物有狗和猫。



#### 6.4 多态的优缺点

**好处**：变量引用的子类对象不同，执行的方法就不同，实现**动态绑定**。代码编写更灵活、功能更强大，可维护性和扩展性更好了。

**弊端**：不能再直接访问子类中添加的属性和方法。属性是在编译时确定的，子类独有的属性不能被多态的父类引用使用。



> 开发中：
>
> 使用父类做方法的形参，是多态使用最多的场合。即使增加了新的子类，方法也无需改变，提高了扩展性，符合开闭原则。比如宠物中增加了小羊，不用修改原有的方法。
>
> 【开闭原则OCP】
>
> - 对扩展开放，对修改关闭
> - 通俗解释：软件系统中的各种组件，如模块（Modules）、类（Classes）以及功能（Functions）等，应该在不修改现有代码的基础上，引入新功能



#### 6.5 虚方法调用(Virtual Method Invocation)

多态情况下，子类中定义了与父类同名同参数的方法，父类的方法称为虚方法。

> 拓展：
>
> **静态链接（或早起绑定）**：当一个字节码文件被装载进JVM内部时，如果被调用的目标方法在编译期可知，且运行期保持不变时。这种情况下将调用方法的符号引用转换为直接引用的过程称之为静态链接。那么调用这样的方法，就称为非虚方法调用。比如调用静态方法、私有方法、final方法、父类构造器、本类重载构造器等。
>
> **动态链接（或晚期绑定）**：如果被调用的方法在编译期无法被确定下来，也就是说，只能够在程序运行期将调用方法的符号引用转换为直接引用，由于这种引用转换过程具备动态性，因此也就被称之为动态链接。调用这样的方法，就称为虚方法调用。比如调用重写的方法（针对父类）、实现的方法（针对接口）。



#### 6.6 成员变量没有多态性

即使子类里定义了与父类完全相同的实例变量，这个实例变量依然不可能覆盖父类中定义的实例变量。

**编译时，看左边；运行时，还看左边。**



#### 6.7 向上转型与向下转型

##### 6.7.1 转型原因

若子类访问自己独有的属性和方法，会出现编译错误。为了解决访问子类独有的属性和方法，需要类型转换，使编译通过。即“向下转型”。



##### 6.7.2 如何转型

![image-20240229204234583](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240229204234583.png)

类比基本数据类型的转型。

向上转型就是多态，自动完成。

向下转型在前面加个括号，为了安全，可以通过isInstanceof关键字进行判断

```java
Pet pet = new Dog();
Dog d = (Dog) pet;//向下转型，成功

Cat c = (Cat) pet;//编译通过，因为从语法检查来说，pet的编译时类型是Pet，Cat是Pet的子类，所以向下转型语法正确
//这句代码运行报错ClassCastException，因为pet变量的运行时类型是Dog，Dog和Cat之间是没有继承关系的
```



##### 6.7.3 instanceof关键字

用于避免ClassCastException异常。

```java
//检验对象a是否是数据类型A的对象，返回值为boolean型，可以和if等一起用
对象a instanceof 数据类型A 
```

注意：

- 如果对象a属于类A的子类B，a instanceof A值也为true。
- 要求对象a所属的类与类A必须是子类和父类的关系，否则编译错误。



### 7. Object类的使用

#### 7.1 理解根父类

类 `java.lang.Object`是类层次结构的根类，即所有其它类的父类。每个类都使用 `Object` 作为超类。

- 不指定父类的类默认继承自Object类
- Object类型的变量与除Object以外的任意引用数据类型的对象都存在多态引用
- 所有对象（包括数组）都实现这个类的方法。



#### 7.2 Object类的方法

##### 7.2.1 (重点)equals()

- ==：基本类型比较值，引用类型比较地址，两边数据类型必须兼容（可自动转换的基本数据类型除外）
- equals()：所有类都继承了Object，也就获得了equals()方法。还可以重写。
  - 只能比较引用类型，Object类源码中equals()的作用与“==”相同。
  - 特例：对类File、String、Date及包装类（Wrapper Class）来说，是比较类型及内容，而非地址，因为在这些类中重写了Object类的equals()方法。
  - 自定义equals()时，可以重写。用于比较两个对象的“内容”是否都相等
  - 重写equals()方法的原则：对称性，自反性，传递性，一致性，任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。



##### 7.2.2 (重点)toString()

- 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"
- 其他数据类型和String连接时默认调用toString()方法
- System.out.println(对象)，默认会自动调用这个对象的toString()
  - Java对程序员隐藏内存地址信息，所以不能直接将内存地址显示出来
- 可以根据需要在用户自定义类型中重写toString()方法



##### 7.2.3 clone()

Object的clone方法是protected，所以不能在类外访问克隆一个对象，需要对clone重写。同时需要实现Cloneable接口（implements Cloneable）。

浅克隆：原对象和克隆对象不同,但对象内的成员引用相同

深克隆：原对象和克隆对象不同,且对象内的成员引用也不同

**深克隆的实现**

- 多层实现Cloneable类：让成员中的引用类型进行clone，多层实现。
- 利用序列化和反序列化：利用序列化对象后可将其拷贝到流里,而原对象仍在jvm中,然后从流中将其反序列化成另一个对象到jvm中,从而实现深克隆。需要实现Serializable接口，不用实现Cloneable接口。相当于新写一个克隆方法。

扩展：Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。



##### 7.2.4 finalize()

当对象被回收时，系统自动调用该对象的 finalize() 方法。不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。

子类可以重写该方法，目的是在对象被清理之前执行必要的清理操作。比如需要在对象被清理之前执行必要的清理操作，在方法内断开相关连接资源等。



##### 7.2.5 getClass()

获取对象的运行时类型



##### 7.2.6 hashCode()

返回每个对象的hash值。



#### 7.3 native关键字的理解

使用native关键字说明这个方法是原生函数，也就是这个方法是用`C/C++`等非Java语言实现的，并且`被编译成了DLL`，由Java去调用。有些层次的任务用java实现起来不容易或对程序的效率很在意时，可以使用native方法。native声明的方法，对于调用者，可以当做和其他Java方法一样使用。

在Java中定义一个native方法时，并不提供实现体。

##### 实现步骤

可以将native方法比作Java程序同Ｃ程序的接口，其实现步骤：

１、在Java中声明native()方法，然后编译；

２、用javah产生一个.h文件；

３、写一个.cpp文件实现native导出方法，其中需要包含第二步产生的.h文件（注意其中又包含了JDK带的jni.h文件）；

４、将第三步的.cpp文件编译成动态链接库文件；

５、在Java中用System.loadLibrary()方法加载第四步产生的动态链接库文件，这个native()方法就可以在Java中被访问了。

