# Part 11 数据结构与集合源码

### 1. 数据结构概述

几种逻辑结构，几种物理结构，运算结构。有哪些，及优缺点



### 2. 一维数组

物理结构特点，优缺点



### 3. 链表

逻辑结构，物理结构，及其存储特点。

有单链表，双链表，循环单链表等常见形式。



### 4. 栈

特点，核心类库中的栈结构有Stack（顺序栈）和LinkedList（链式栈）。常见操作方法，及时间复杂度。



### 5. 队列

特点，物理结构，修改原则



### 6. 树

专有名词，比如结点，根节点等。

二叉树的基本概念，三种遍历及层序遍历。

满二叉树，完全二叉树，二叉排序/查找/搜索树，平衡二叉树，红黑树。



### 7. List接口分析

List集合关心元素是否有序，而不关心是否重复。

List接口的主要实现类

- ArrayList：动态数组
- Vector：动态数组
- LinkedList：双向链表
- Stack：栈

#### 7.1 动态数组ArrayList与Vector

##### 7.1.1 ArrayList VS Vector

|                            | ArrayList                                                    | Vector |
| -------------------------- | ------------------------------------------------------------ | ------ |
| 是否线程安全               | 不，但效率高                                                 | 是     |
| 扩容机制                   | 1.5倍                                                        | 2倍    |
| 初始化容量（没有显式指定） | JDK8.0之前是10；JDK8.0只有初始化为0，在添加第一个元素才创建长度为10的数组，避免浪费 | 10     |



#### 7.2 链表LinkedList

LinkedList是一个`双向链表`。



### 8. Map接口分析

#### 8.1 哈希表的物理结构

数组 + 链表(JDK7) ---> 数组 + 红黑树(JDK8)



#### 8.2 HashMap中数据添加过程

##### 8.2.1 JDK7中过程分析

将(key1,value1)添加到当前hashmap的对象中。

- 首先会调用key1所在类的hashCode()方法，计算key1的哈希值1，此哈希值1再经过某种运算(hash())，得到哈希值2。此哈希值2再经过某种运算(indexFor())，确定在底层table数组中的索引位置i。
  1. 如果数组索引为i上的数据为空，则(key1,value1)直接添加成功
  2. 如果数组索引为i上的数据不为空，有(key2,value2)，则需要进一步判断，判断key1的哈希值2与key2的哈希值是否相同
     1. 如果哈希值不同，则(key1,value1)直接添加成功
     2. 如果哈希值相同，则需要继续调用key1所在类的equals()方法，将key2放入equals()形参进行判断
        1. equals方法返回false : 则(key1,value1)直接添加成功
        2. equals方法返回true : 默认情况下，value1会覆盖value2。

- 在不断的添加的情况下，满足如下条件的情况下，会进行扩容:
  if ((size >= threshold) && (null != table[bucketIndex])) :
  默认情况下，当要添加的元素个数超过12(即：数组的长度 * loadFactor得到的结果)时，就要考虑扩容。



##### 8.2.2 JDK8中过程分析

1. 使用HashMap()的构造器创建对象时，并没有在底层初始化长度为16的table数组。

2. jdk8中添加的key,value封装到了HashMap.Node类的对象中。而非jdk7中的HashMap.Entry。

3. jdk8中新增的元素所在的索引位置如果有其他元素。在经过一系列判断后，如果能添加，则是旧的元素指向新的元素。而非jdk7中的新的元素指向旧的元素。“七上八下”

4. jdk7时底层的数据结构是：数组+单向链表。 而jdk8时，底层的数据结构是：数组+单向链表+红黑树。

   > 红黑树出现的时机：当某个索引位置i上的链表的长度达到8，且数组的长度超过64时，此索引位置上的元素要从单向链表改为红黑树。如果索引i位置是红黑树的结构，当不断删除元素的情况下，当前索引i位置上的元素的个数低于6时，要从红黑树改为单向链表。



### 9. Set接口分析

#### 9.1 Set集合与Map集合的关系

Set的内部实现其实是一个Map，Set中的元素，存储在HashMap的key中。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。



### 10. 【拓展】HashMap的相关问题

#### 1、说说你理解的哈希算法

hash算法是一种可以从任何数据中提取出其“指纹”的数据摘要算法，它将任意大小的数据映射到一个固定大小的序列上，这个序列被称为hash code、数据摘要或者指纹。比较出名的hash算法有MD5、SHA。hash是具有唯一性且不可逆的，唯一性是指相同的“对象”产生的hash code永远是一样的。

#### 2、Entry中的hash属性为什么不直接使用key的hashCode()返回值呢？

不管是JDK1.7还是JDK1.8中，都不是直接用key的hashCode值直接与table.length-1计算求下标的，而是先对key的hashCode值进行了一个运算，JDK1.7和JDK1.8关于hash()的实现代码不一样，但是不管怎么样都是为了提高hash code值与 (table.length-1)的按位与完的结果，尽量的均匀分布。

虽然算法不同，但是思路都是将hashCode值的高位二进制与低位二进制值进行了异或，然高位二进制参与到index的计算中。

**为什么要hashCode值的二进制的高位参与到index计算呢？**

因为一个HashMap的table数组一般不会特别大，至少在不断扩容之前，那么table.length-1的大部分高位都是0，直接用hashCode和table.length-1进行&运算的话，就会导致总是只有最低的几位是有效的，那么就算你的hashCode()实现的再好也难以避免发生碰撞，这时让高位参与进来的意义就体现出来了。它对hashcode的低位添加了随机性并且混合了高位的部分特征，显著减少了碰撞冲突的发生。



#### 3、HashMap是如何决定某个key-value存在哪个桶的呢？

因为hash值是一个整数，而数组的长度也是一个整数，有两种思路：

①hash 值 % table.length会得到一个[0,table.length-1]范围的值，正好是下标范围，但是用%运算效率没有位运算符&高。

②hash 值 & (table.length-1)，任何数 & (table.length-1)的结果也一定在[0, table.length-1]范围。



#### 4、为什么要保持table数组一直是2的n次幂呢？

因为如果数组的长度为2的n次幂，那么table.length-1的二进制就是一个高位全是0，低位全是1的数字，这样才能保证每一个下标位置都有机会被用到。



#### 5、解决[index]冲突问题

虽然从设计hashCode()到上面HashMap的hash()函数，都尽量减少冲突，但是仍然存在两个不同的对象返回的hashCode值相同，或者hashCode值就算不同，通过hash()函数计算后，得到的index也会存在大量的相同，因此key分布完全均匀的情况是不存在的。那么发生碰撞冲突时怎么办？

JDK1.8之间使用：数组+链表的结构。

JDK1.8之后使用：数组+链表/红黑树的结构。



#### 6、为什么JDK1.8会出现红黑树和链表共存呢？

因为当冲突比较严重时，table[index]下面的链表就会很长，那么会导致查找效率大大降低，而如果此时选用二叉树可以大大提高查询效率。

但是二叉树的结构又过于复杂，占用内存也较多，如果结点个数比较少的时候，那么选择链表反而更简单。所以会出现红黑树和链表共存。



#### 7、加载因子的值大小有什么关系？

如果太大，threshold就会很大，那么如果冲突比较严重的话，就会导致table[index]下面的结点个数很多，影响效率。

如果太小，threshold就会很小，那么数组扩容的频率就会提高，数组的使用率也会降低，那么会造成空间的浪费。



#### 8、什么时候树化？什么时候反树化？

```java
static final int TREEIFY_THRESHOLD = 8;//树化阈值
static final int UNTREEIFY_THRESHOLD = 6;//反树化阈值
static final int MIN_TREEIFY_CAPACITY = 64;//最小树化容量
```

* 当某table[index]下的链表的结点个数达到8，并且table.length>=64，那么如果新Entry对象还添加到该table[index]中，那么就会将table[index]的链表进行树化。

* 当某table[index]下的红黑树结点个数少于6个，此时，
  * 当继续删除table[index]下的树结点，最后这个根结点的左右结点有null，或根结点的左结点的左结点为null，会反树化
  * 当重新添加新的映射关系到map中，导致了map重新扩容了，这个时候如果table[index]下面还是小于等于6的个数，那么会反树化



#### 9、key-value中的key是否可以修改？

key-value存储到HashMap中会存储key的hash值，这样就不用在每次查找时重新计算每一个Entry或Node（TreeNode）的hash值了，因此如果已经put到Map中的key-value，再修改key的属性，而这个属性又参与hashcode值的计算，那么会导致匹配不上。

这个规则也同样适用于LinkedHashMap、HashSet、LinkedHashSet、Hashtable等所有散列存储结构的集合。



#### 10、JDK1.7中HashMap的循环链表是怎么回事？如何解决？

避免HashMap发生死循环的常用解决方案：

- 多线程环境下，使用线程安全的ConcurrentHashMap替代HashMap，推荐
- 多线程环境下，使用synchronized或Lock加锁，但会影响性能，不推荐
- 多线程环境下，使用线程安全的Hashtable替代，性能低，不推荐

HashMap死循环只会发生在JDK1.7版本中，主要原因：头插法+链表+多线程并发+扩容。

在JDK1.8中，HashMap改用尾插法，解决了链表死循环的问题。

![image-20240302204801487](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240302204801487.png)

扩容时遍历链表中的每个节点，计算其在扩容后的位置，遍历方式为头插法。上图中，若A,B,C扩容后依然属于下标为2的位置。线程T1停在指向A，并记录下一个为B。同样的，线程T2停在指向A，并记录下一个为B。线程T2先扩容完成，由于是头插法扩容，可能导致扩容后B指向A。再执行T1时，进行扩容，在T1看来，A和B相互指，形成循环，头插法扩容就出现了死循环。

