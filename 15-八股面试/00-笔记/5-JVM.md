## 一、JVM组成

JVM是什么？由哪些部分组成，运行流程是什么？

> JVM全称是Java Virtual Machine，是java二进制字节码的运行环境。存在在程序和操作系统之间。好处是一次编写，到处运行，有自动内存管理，垃圾回收机制。
>
> 主要由ClassLoader（类加载器），Runtime Data Area（运行时数据区，内存分区），Execution Engine（执行引擎），Native Method Library（本地库接口）组成。
>
> 其运行流程为
>
> 1. 类加载器（ClassLoader）把Java代码转换为字节码。
> 2. 运行时数据区（Runtime Data Area）把字节码加载到内存中，而字节码文件只是JVM的一套指令集规范，并不能直接交给底层系统去执行，而是有执行引擎运行。
> 3. 执行引擎（Execution Engine）将字节码翻译为底层系统指令，再交由CPU执行去执行，此时需要调用其他语言的本地库接口（Native Method Library）来实现整个程序的功能。



什么是程序计数器？

> 是线程私有的，内部保存的字节码的行号。用于记录正在执行的字节码指令的地址。主要用于线程切换的恢复工作，记录了上次执行到的行号，便于继续执行。
>
> 程序计数器是JVM规范中唯一一个没有规定出现OOM的区域，所以这个空间也不会进行GC。



你能给我详细的介绍Java堆吗?

> 堆是一个线程共享的区域，主要用来保存对象实例，数组等，当堆中没有内存空间可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。
>
> 堆空间中有年轻代和老年代。其中年轻代被划分为三部分，Eden区和两个大小严格相同的Survivor区，根据JVM的策略，在经过几次垃圾收集后，仍然存活于Survivor的对象将被移动到老年代区间。老年代主要保存生命周期长的对象，一般是一些老的对象。
>
> 对于元空间，元空间保存的类信息、静态变量、常量、编译后的代码。在java8前这些信息保存在堆中一个称为方法区或者永久代的结构中，在java8之后将该结构移动到了本地内存上重新开辟了一块空间，称为元空间。
>
> 优化原因：永久代是有大小限制的，因此如果加载的类太多，很有可能导致永久代内存溢出，即OutOfMemoryError，为此不得不对虚拟机做调优。



什么是虚拟机栈

> 每个线程运行时所需要的内存，称为虚拟机栈，先进后出。每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存。每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法。



垃圾回收是否涉及栈内存？

> 垃圾回收主要指就是堆内存，当栈帧弹栈以后，内存就会释放。



栈内存分配越大越好吗？

> 未必，默认的栈内存通常为1024k
>
> 栈帧过大会导致线程数变少，例如，机器总内存为512m，目前能活动的线程数则为512个，如果把栈内存改为2048k，那么能活动的栈帧就会减半



方法内的局部变量是否线程安全？

> 如果方法内局部变量没有逃离方法的作用范围，它是线程安全的。如果是局部变量引用了对象，并逃离方法的作用范围，需要考虑线程安全。



栈内存溢出情况

> 栈帧过多导致栈内存溢出，典型问题：递归调用。
>
> 栈帧过大导致栈内存溢出。



堆栈的区别是什么？

> 1、栈内存一般会用来存储局部变量和方法调用，但堆内存是用来存储Java对象和数组的的。堆会GC垃圾回收，而栈不会。
>
> 2、栈内存是线程私有的，而堆内存是线程共有的。
>
> 3、两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。
>
> 栈空间不足：java.lang.StackOverFlowError。
>
> 堆空间不足：java.lang.OutOfMemoryError。



能不能解释一下方法区？

> 方法区(Method Area)是各个线程共享的内存区域，主要存储类的信息、运行时常量池。虚拟机启动的时候创建，关闭虚拟机时释放。如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace。
>
> 其中常量池可以看作是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息。常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址。
>
> 查看字节码结构（类的基本信息、常量池、方法定义）`javap -v xx.class`



你听过直接内存吗？

> 不受 JVM 内存回收管理，是虚拟机的系统内存，常见于 NIO 操作时，用于数据缓冲区，分配回收成本较高，但读写性能高，不受 JVM 内存回收管理。NIO传输数据时，使用到了一个直接内存，不需要在堆中开辟空间进行数据的拷贝，jvm可以直接操作直接内存，从而使数据读写传输更快。



## 二、类加载器

什么是类加载器，类加载器有哪些？

> 类加载器（ClassLoader）的主要作用就是将**字节码文件加载到JVM中**，从而让Java程序能够启动起来。
>
> 现有的类加载器基本上都是java.lang.ClassLoader的子类，该类的主要职责就是用于将指定的类找到或生成对应的字节码文件，同时类加载器还会负责加载程序所需要的资源。
>
> 类加载器根据各自加载范围的不同，划分为四种类加载器：
>
> 1. **启动类加载器(BootStrap ClassLoader)：**该类并不继承ClassLoader类，其是由C++编写实现。用于加载**JAVA_HOME/jre/lib**目录下的类库。
> 2. **扩展类加载器(ExtClassLoader)：**该类是ClassLoader的子类，主要加载**JAVA_HOME/jre/lib/ext**目录中的类库。
> 3. **应用类加载器(AppClassLoader)：**该类是ClassLoader的子类，主要用于加载**classPath**下的类，也就是加载开发者自己编写的Java类。
> 4. **自定义类加载器：**开发者自定义类继承ClassLoader，实现自定义类加载规则。



什么是双亲委派模型？

> 如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就返回成功；只有父类加载器无法完成此加载任务时，才由下一级去加载。 



JVM为什么采用双亲委派机制

> - 通过双亲委派机制可以避免某一个类被重复加载，当父类已经加载后则无需重复加载，保证唯一性。
> - 为了安全，保证类库API不会被修改。比如



说一下类装载的执行过程？

> 类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。
>
> 1. 加载：通过类的全名，获取类的二进制数据流。解析类的二进制数据流为方法区内的数据结构。创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口
> 2. 验证：验证类是否符合JVM规范，安全性检查。
>    1. 文件格式验证
>    2. 元数据验证
>    3. 字节码验证
>    4. 符号引用验证
> 3. 准备：为类变量分配内存并设置类变量初始值
> 4. 解析：把类中的符号引用转换为直接引用
> 5. 初始化：对类的静态变量，静态代码块执行初始化操作
> 6. 使用：JVM 开始从入口方法开始执行用户的程序代码
> 7. 卸载：当用户程序代码执行完毕后，JVM 便开始销毁创建的 Class 对象，最后负责运行的 JVM 也退出内存



## 三、垃圾回收

> 垃圾回收（没有任何应用指向它时，该对象就是垃圾）
>
> 该过程的实现
>
> - 判断是否为垃圾
>   - 引用计数法（对循环引用无效，内存泄漏）
>   - 可达性分析算法（GCRoots可达的对象是存活的）
>     - GCRoots可以是虚拟机栈中引用的对象，方法区中类静态属性引用的对象，方法区中常量引用的对象
> - 垃圾回收算法
>   - 标记清除算法
>   - 标记整理算法
>   - 复制算法
> - 分代收集算法
> - 垃圾回收器
>   - 串行垃圾回收器：有一个线程进行垃圾回收，其余线程阻塞。对于新生代，使用复制算法，对于老年代使用标记整理算法
>   - 并行垃圾回收器：有多个线程进行垃圾回收，其余线程阻塞。对于新生代，使用复制算法，对于老年代使用标记整理算法
>   - CMS并发垃圾回收器：分四个阶段，第一阶段阻塞标记根对象，第二阶段用可达性分析算法并发标记其余对象，第三阶段阻塞标记一些第二阶段产生的新对象，清除的老对象，第四阶段并发清理。主要作用在老年代。
>   - G1垃圾回收器：



简述Java垃圾回收机制？（GC是什么？为什么要GC）

> 这是自动的垃圾回收机制。程序员只需要关心内存申请，剩下的交给JVM。对于不同的对象引用类型，GC采用不同的回收时机。而此时自动垃圾回收算法也很重要，如果因为算法的不合理，导致内存资源一直没有释放，同样也可能会导致内存溢出的。



对象什么时候可以被垃圾器回收（定位垃圾的算法）

> 简单一句就是：如果一个或多个对象没有任何的引用指向它了，那么这个对象现在就是垃圾，如果定位了垃圾，则有可能会被垃圾回收器回收。
>
> 有两种方式定位垃圾：一是引用计数法，二是可达性分析算法。
>
> - 引用计数法就是在当前对象头上递增一次引用次数，引用次数为0代表这个对象可回收。但是当出现了循环引用，这个方法就会失效。
>   - 优点
>     - 实时性较高，无需等到内存不够的时候，才开始回收，运行时根据对象的计数器是否为0，就可以直接回收。
>     - 在垃圾回收过程中，应用无需挂起。如果申请内存时，内存不足，则立刻报OOM错误。
>     - 区域性，更新对象的计数器时，只是影响到该对象，不会扫描全部对象。
>   - 缺点
>     - 每次对象被引用时，都需要去更新计数器，有一点时间开销。
>     - **浪费CPU资源**，即使内存够用，仍然在运行时进行计数器的统计。
>     - **无法解决循环引用问题，会引发内存泄露**。（最大的缺点）
> - 可达性分析算法，也是目前大多数JVM会采用的算法。它的原理是检查根对象能访问到的下一层节点，从该层节点继续找出其下面的节点，以此类推，直到所有的节点全部遍历完毕。回收过程是跟踪对象之间的引用关系形成引用图，将无法从根对象访问到的对象判定为不再存活，用垃圾回收器对其进行回收。（回收过程首先会判断这个对象是否执行了finalize方法，如果没有执行，则会先执行该方法，接着在这个方法执行中，可以设置当前这个对象与GC ROOTS产生关联，那么这个方法执行完成之后，GC会再次判断对象是否可达，如果仍然不可达，则会进行回收，如果可达了，则不会进行回收。）



JVM 垃圾回收算法有哪些？

> 有三种常见的垃圾回收算法。标记清除算法，复制算法，标记整理。
>
> - 标记清除算法
>
>   1. 标记：根据可达性分析算法得出的垃圾进行标记
>   2. 回收：对这些标记为可回收的内容进行垃圾回收
>
>   - 优点：解决了引用计数算法中的循环引用的问题，没有从root节点引用的对象都会被回收。
>   - 缺点：效率较低，**标记和清除两个动作都需要遍历所有的对象**，并且在GC时，**需要停止应用程序**，对于交互性要求比较高的应用而言这个体验是非常差的。（**重要**）通过标记清除算法清理出来的内存，碎片化较为严重，因为被回收的对象可能存在于内存的各个角落，所以清理出来的内存是不连贯的。
>
> - 复制算法
>
>   - **将原有的内存空间一分为二，每次只用其中的一块**，在垃圾回收时，将正在使用的对象复制到另一个内存空间中，然后将该内存空间清空，交换两个内存的角色，完成垃圾的回收。
>   - 如果内存中的垃圾对象较多，需要复制的对象就较少，这种情况下适合使用该方式并且效率比较高，反之，则不适合。 
>   - 优点：在垃圾对象多的情况下，效率较高。清理后，内存无碎片。
>   - 缺点：分配的2块内存空间，在同一个时刻，只能使用一半，内存使用率较低。
>
> - 标记整理算法
>
>   - 标记过程和标记清除算法的一样。
>   - 整理是指将存活对象都向内存的另一端移动，然后清理边界以外的垃圾，从而解决了碎片化的问题。
>   - 优缺点同标记清除算法，解决了标记清除算法的碎片化的问题，同时，标记压缩算法多了一步，对象移动内存位置的步骤，其效率也有有一定的影响。



说一下JVM的分代收集算法

> java8时堆被分成了两份：新生代，老年代。其中新生代占三分之一，老年代占三分之二，新生代中Eden区，S0区，S1区【8：1：1】。
>
> 新生代的GC为MinorGC【young GC】，老年代的GC为Major GC。
>
> 工作机制
>
> - 新创建的对象，都会先分配到eden区
> - 当伊甸园内存不足，标记伊甸园与 from（现阶段没有）的存活对象
> - 将存活对象采用复制算法复制到 to 中，复制完毕后，伊甸园和 from 内存都得到释放
> - 经过一段时间后伊甸园的内存又出现不足，标记eden区域to区存活的对象，将存活的对象复制到from区
> - 当幸存区对象熬过几次回收（最多15次），晋升到老年代（幸存区内存不足或大对象会导致提前晋升）
>
> **MinorGC、 Mixed GC 、 FullGC的区别是什么**
>
> - MinorGC【young GC】发生在新生代的垃圾回收，暂停时间短（STW）
> - Mixed GC 新生代 + 老年代部分区域的垃圾回收，G1 收集器特有
>
> - FullGC： 新生代 + 老年代完整垃圾回收，暂停时间长（STW），应尽力避免



说一下 JVM 有哪些垃圾回收器？

> 在jvm中，实现了多种垃圾收集器，包括：
>
> - 串行垃圾收集器
>
> - 并行垃圾收集器
>
> - CMS（并发）垃圾收集器
>
> - G1垃圾收集器
>
> 
>
> - 串行垃圾收集器：Serial和Serial Old串行垃圾收集器，是指使用单线程进行垃圾回收，堆内存较小，适合个人电脑。
>   - Serial 作用于新生代，采用复制算法
>   - Serial Old 作用于老年代，采用标记-整理算法
>   - 垃圾回收时，只有一个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
> - 并行垃圾收集器：Parallel New和Parallel Old是一个并行垃圾回收器，**JDK8默认使用此垃圾回收器**
>   - Parallel New作用于新生代，采用复制算法
>   - Parallel Old作用于老年代，采用标记-整理算法
>   - 垃圾回收时，多个线程在工作，并且java应用中的所有线程都要暂停（STW），等待垃圾回收的完成。
> - CMS（并发）垃圾收集器：CMS全称 Concurrent Mark Sweep，是一款并发的、使用标记-清除算法的垃圾回收器，该回收器是针对老年代垃圾回收的，是一款以获取最短回收停顿时间为目标的收集器，停顿时间短，用户体验就好。其最大特点是在进行垃圾回收时，应用仍然能正常运行。
>   - 第一阶段是对根对象进行初始标记，需要STW
>   - 第二阶段是根据根对象对可达对象进行标记，不需要STW
>   - 第三阶段是重新标记，因为在并发标记的过程中还可能会出现新的节点，还可能存在有过期的节点，需要STW
>   - 第四阶段将没有标记可达的节点清除（不是立即清除），不需要STW



详细聊一下G1垃圾回收器

> 应用于新生代和老年代，在JDK9之后默认使用**G1**
>
> 将内存划分为多个区域，每个区域都可能是eden，survivor，old， humongous，其中 humongous 专为大对象准备。主要看运行时的情况。
>
> 分为三个阶段：新生代回收，并发标记，混合收集。采用的是复制算法。
>
> - 新生代回收
>   - 挑选一些空闲区域作为Eden园区存储这些对象。
>   - 当Eden区内存不足时，需要进行垃圾回收，会挑选一个空闲区域作为幸存区，将存活对象从Eden区中复制过去。需要STW
>   - 当Eden区又出现内存不足时，需要将Eden区和幸存区中的赋值到新的幸存区中，如果有较老的对象，会晋升至老年代。
> - 并发标记
>   - 当老年代占用内存超过阈值(默认是45%)后，触发并发标记，这时无需暂停用户线程。（参考CMS的第二阶段）
>   - 并发标记之后，会有重新标记阶段解决漏标问题，此时需要暂停用户线程。（参考CMS的第三阶段）
> - 混合垃圾回收
>   - G1 GC会根据每个Region的垃圾堆积情况和回收价值进行排序，并选择性地回收部分Region中的垃圾对象。回收过程包括将存活的对象从一个Region复制或移动到另一个Region，并更新相关的引用。（Gabage First）
>
> 另外，humongous是给大对象准备的，开辟一块连续的存储空间存储巨型对象。



强引用、软引用、弱引用、虚引用的区别？

> - 强引用
>   - 如果一个对象具有强引用，那就类似于**必不可少的**物品，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。
>   - 当离开作用域才可能会回收。
> - 软引用
>   - 用来描述一些**有用但并不是必需**的对象，对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
> - 弱引用
>   - 也是用来描述**非必需对象**的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
>   - 弱引用与软引用的区别在于**：**只具有弱引用的对象拥有更短暂的生命周期。
> - 虚引用
>   - 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。虚引用主要用来跟踪对象被垃圾回收的活动。
>   - 虚引用必须和引用队列关联使用，当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会把这个虚引用加入到与之关联的引用队列中。
>
> | 引用类型 | 被回收时间    | 用途           | 生存时间      |
> | -------- | ------------- | -------------- | ------------- |
> | 强引用   | 从来不会      | 对象的一般状态 | JVM停止运行时 |
> | 软引用   | 内存不足时    | 对象缓存       | 内存不足时    |
> | 弱引用   | jvm垃圾回收时 | 对象缓存       | gc运行后      |
> | 虚引用   | 未知          | 未知           | 未知          |



## 四、JVM实践（调优）

JVM 调优的参数可以在哪里设置参数值？

> - tomcat的设置vm参数：修改catalina文件
> - springboot项目jar文件启动：命令加参数



用的 JVM 调优的参数都有哪些？

> 对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。
>
> 1. 设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。
>    - -Xms：设置堆的初始化大小
>    - -Xmx：设置堆的最大大小
> 2. 设置年轻代中Eden区和两个Survivor区的大小比例。该值如果不设置，则默认比例为8:1:1。Java官方通过增大Eden区的大小，来减少YGC发生的次数，但有时我们发现，虽然次数减少了，但Eden区满的时候，由于占用的空间较大，导致释放缓慢，此时STW的时间较长，因此需要按照程序情况去调优。
>    - -XXSurvivorRatio=3，表示年轻代中的分配比率：survivor:eden = 2:3
> 3. 年轻代和老年代默认比例为1：2。可以通过调整二者空间大小比率来设置两者的大小。
>    - -XX:newSize   设置年轻代的初始大小
>    - -XX:MaxNewSize   设置年轻代的最大大小，初始大小和最大大小两个值通常相同
> 4. 线程堆栈的设置：**每个线程默认会开启1M的堆栈**，用于存放栈帧、调用参数、局部变量等，但一般256K就够用。通常减少每个线程的堆栈，可以产生更多的线程，但这实际上还受限于操作系统。
>    - -Xss   对每个线程stack大小的调整,-Xss128k
> 5. 一般来说，当survivor区不够大或者占用量达到50%，就会把一些对象放到老年区。通过设置合理的eden区，survivor区及使用率，可以将年轻对象保存在年轻代，从而避免full GC，使用-Xmn设置年轻代的大小













