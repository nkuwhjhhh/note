## 一、缓存穿透、击穿、雪崩

什么是缓存穿透 ? 怎么解决 ?



你能介绍一下布隆过滤器吗？

> 可以用于数据库，也可以用于过滤web请求。



什么是缓存击穿 ? 怎么解决 ?



什么是缓存雪崩 ? 怎么解决 ?



## 二、双写一致性

> 是指在写数据的时候将数据库中的数据和redis缓存中的数据保持一致。
>
> 读：先读redis，不命中再读数据库，并将数据缓存在redis中。
>
> 写：下面介绍
>
> 思考角度：
>
> - 先删缓存，再改数据库（不一致）
>   - 采用延时双写：删缓存——改数据库—（延时）—删缓存
>   - 两次删缓存原因？第二次删是因为第一次删和该数据库之间有访问，导致旧数据重新写入缓存，延时是因为数据库有主从的话主从复制过程需要时间，如果在第二次删缓存之前还没有复制完成，那么删完再更新数据可能还会出现和第一次一样的情况。
> - 先改数据库，再更新缓存（不一致）
>   - 也会有数据不一致的情况出现。先来了读请求，获取到redis中的旧数据，未返回数据之前，切换线程，完成了数据库修改的过程，此时再切换回原来的线程，就会将原来读到的旧数据返回给用户。
> - 分布式锁（强一致性）
>   - 可以使用redisson实现的读写锁。redisson的读写锁有共享锁和排他锁。
>   - 排他锁用于写，共享锁用于读。写请求到来的时候拿到排他锁，进行数据库的修改操作和缓存的删除操作。之后的读请求到来的时候拿到共享锁，对redis请求，redis中没有数据的时候再请求数据库读取数据。
> - 使用canal组件（不能强一致）
>   - 优点：不需要更改业务代码，会将自己伪装成一个mysql的从节点，mysql数据更新之后，在主从复制的过程中，该组件会读取binlog数据，再去更新缓存。



redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）

> 只有写的时候才有数据同步一说。不写的话数据不会改变，也不会发生不一致的情况。



那这个排他锁是如何保证读写、读读互斥的呢？

> 排他锁底层使用也是setnx，保证了同时只能有一个线程操作锁住的方法



你听说过延时双删吗？为什么不用它呢？



redis做为缓存，mysql的数据如何与redis进行同步呢？（双写一致性）





## 三、持久化

redis做为缓存，数据的持久化是怎么做的？



这两种持久化方式有什么区别呢？



这两种方式，哪种恢复的比较快呢？



## 四、删除策略

Redis的数据过期策略有哪些 ? 

> 惰性删除
>
> 定期删除
>
> - slow模式：定时任务
> - fast模式：执行频率不固定，两次间隔不低于2ms，每次耗时不超过1ms。
>
> redis采用的是两种策略结合的方式。



Redis的数据淘汰策略有哪些 ? 

> redis默认不淘汰。有一些策略可以自己配置，其主要思想是随机，LRU，LFU。



数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的数据都是热点数据 ?

> 使用allkeys-lru策略。



Redis的内存用完了会发生什么？

> 看淘汰策略，如果没有淘汰策略，则报错，如果有，则按照淘汰策略进行淘汰。



## 五、分布式锁

Redis分布式锁如何实现 ? 

> setnx



如何控制Redis实现分布式锁有效时长呢？

> 简单：setnx设置过期时间
>
> 问题：时间设置问题，运行时间过长，自动释放锁。
>
> 使用redisson



redisson实现的分布式锁是可重入的吗？



redisson实现的分布式锁能解决主从一致性的问题吗

> 不能：当master宕机的时候，还没来得及完成主从复制。
>
> 解决：红锁。大部分redis都给锁才算获取锁成功。效率低，维护成本高，目前官方废弃了。



如果业务非要保证数据的强一致性，这个该怎么解决呢？

> redis本身就是支持高可用的，做到强一致性，就非常影响性能，所以，如果有强一致性要求高的业务，建议使用zookeeper实现的分布式锁，它是可以保证强一致性的。



## 六、Redis集群

Redis集群有哪些方案, 知道嘛 ? 



介绍一下主从同步



主从同步数据的流程

> 两个阶段，一个是全量同步，一个是增量同步
>
> - 全量同步
>   - 从节点请求主节点同步数据，其中从节点会携带自己的replication id和offset偏移量。
>   - 主节点判断是否是第一次请求，主要判断的依据就是，主节点与从节点是否是同一个replication id，如果不是，就说明是第一次同步，那主节点就会把自己的replication id和offset发送给从节点，让从节点与主节点的信息保持一致。
>   - 在同时主节点会执行bgsave，生成rdb文件后，发送给从节点去执行，从节点先把自己的数据清空，然后执行主节点发送过来的rdb文件，这样就保持了一致
>     - 如果在rdb生成执行期间，依然有请求到了主节点，而主节点会以命令的方式记录到缓冲区，缓冲区是一个日志文件，最后把这个日志文件发送给从节点，这样就能保证主节点与从节点完全一致了，后期再同步数据的时候，都是依赖于这个日志文件，这个就是全量同步
> - 增量同步
>   - 当从节点服务重启之后，数据就不一致了，所以这个时候，从节点会请求主节点同步数据，主节点还是判断不是第一次请求，不是第一次就获取从节点的offset值，然后主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步



保证Redis的高并发高可用

> 主从集群+哨兵模式
>
> 介绍哨兵模式



redis集群脑裂，该怎么解决呢？



redis的分片集群有什么作用

> 多master多slave
>
> 



Redis分片集群中数据是怎么存储和读取的？

> 哈希槽分区、一致性哈希算法分区



Redis是单线程的，但是为什么还那么快？

> 1、完全基于内存的，C语言编写
>
> 2、采用单线程，避免不必要的上下文切换可竞争条件
>
> 3、使用多路I/O复用模型，非阻塞IO



能解释一下I/O多路复用模型？

> redis的性能瓶颈是网络延时而非执行速度。I/O多路复用就是实现了高效的网络请求。

> PS:
>
> - 阻塞IO：用户请求内核缓冲区中的数据，如果数据没准备好，就等着数据准备好
> - 非阻塞IO：用户请求内核缓冲区的数据，如果数据没准备好，则返回未准备好，用户不断询问是否准备好数据，直到数据返回。（不用一直等，而是不断询问，询问的间隔期间会做别的事情，不必一直等待）
> - IO多路复用
>   - 阶段一
>     - 用户进程调用select，指定要监听的socket集合
>     - 内核监听对应的多个socket
>     - 任意一个或多个socket数据就绪返回readable
>     - 此过程中用户进程阻塞
>   - 阶段二
>     - 用户进程找到就绪的socket
>     - 依次调用recvfrom读取数据
>     - 内核将数据拷贝到用户空间
>     - 用户进程处理数据
>   - 优点：内核中的数据不需要依次等待用户的调用，准备好了就可以通知用户来读取。
>   - 实现方式（这里介绍三种）
>     - select、poll：只会通知进程用户就绪，但是不会确定是哪个socket，而是去轮询所有socket
>     - epoll：会通知用户进程就绪，并且会将已就绪的socket写入用户空间