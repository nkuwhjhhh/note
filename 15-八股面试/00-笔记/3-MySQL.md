## 一、慢查询

数据库整体运行状态有变化，怎么解决？

> 1. 观察服务器状态是否存在周期性波动（适用于双十一等促销活动），如果有则加缓存查看效果。
> 2. 以上操作没有解决，可以开启慢查询，设置阈值，对慢查询日志分析
> 3. 使用EXPLAIN语句查看
>    1. 等待时间长，则可以增加数据库缓冲池等
>    2. 执行时间长，则可以从下面几个角度考虑：索引设计的问题？还是查询关联的数据表过多？还是因为数据表的字段设计？
>    3. 如果都不能解决问题，可以考虑服务器是否达到性能瓶颈，考虑增加服务器。



MySQL中，如何定位慢查询?

> 可以使用运维的监控系统。
>
> 也可以使用MySQL中慢日志查询的功能。在系统的配置文件中开启慢日志功能，设置SQL执行超过多久要将该SQL语句记录到日志文件中。



那这个SQL语句执行很慢, 如何分析呢？

> explain。这里可以通过key和key_len检查是否命中了索引，如果已经有了索引可以判断是否出现索引失效的情况。可以通过type字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描。可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复。



explain能做什么？

> - 表的读取顺序
> - 数据读取操作的操作类型
> - **针对单表的访问方法**（重要）
> - 哪些索引可以使用
> - **哪些索引被实际使用**
> - 表之间的引用
> - **每张表有多少行被优化器查询**



EXPLAIN输出结果举例

![image-20240310220903920](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240310220903920.png)

> - id
> - select_type
> - table
> - partitions
> - ==type==
> - possible_keys
> - key
> - ==key_len==
> - ref
> - ==rows==：预估的需要读取的记录条数
> - filtered：返回的行数在读到的行数的占比
> - ==Extra==：额外信息。比如没有用到表，where条件永远为假，使用到了索引，搜索条件中出现了索引列但是不能用到索引，使用到了临时表，等等信息。



## 二、索引

了解过索引吗？（什么是索引）

> 提高检索效率，降低IO成本，通过索引列对数据进行排序，降低排序成本。



索引的底层数据结构了解过嘛 ? 

> 底层采用的是B+数，好处：阶数更多，路径更短；非叶节点只存储指针，不存储数据，读写代价更低；叶子直接用双向链表连接，可以用于区间查询。



B树和B+树的区别是什么呢？



什么是聚簇索引什么是非聚簇索引 ?

> 聚簇索引是针对主键建立的索引，数据和索引放在一起，叶子节点保存了整行数据。
>
> 非聚簇索引是针对除了主键之外的其他属性建立的，可以有多个，只保存当前列和主键值，如果需要完整数据需要去聚簇索引中获取。这个过程也称为回表查询。



知道什么是回表查询嘛 ?



知道什么叫覆盖索引嘛 ? 

> 一个索引包含了满足查询结果的数据就叫做覆盖索引。不用回表，减少搜索次数，提高查询性能。



MYSQL超大分页怎么处理 ?

> 是指MySQL中要查询的表数据量很大，并且使用limit时，起始位置也很大的时候，仅返回一小部分需要的数据，耗时长浪费时间。
>
> 可以创建覆盖索引，先查询需要的数据的id字段，确定字段之后再用子查询过滤，



创建索引

> 方式：`CREATE TABLE`，`ALTER TABLE`，`CREATE INDEX`。
>
> 创建表的时候创建索引`CREATE TABLE`
>
> - 隐式创建：主键，约束都会创建
> - 显式创建：可以创建普通索引，唯一索引，主键索引，组合索引，全文索引，空间索引
>
> 在已存在的表上创建索引
>
> - `ALTER TABLE`
> - `CREATE INDEX`



索引创建原则有哪些？

> 大前提：表中的数据要超过10万以上。
>
> 一般添加索引的字段是查询比较频繁的字段，一般也是像作为查询条件，排序字段或分组的字段这些。
>
> 通常创建索引的时候都是使用复合索引来创建，一条sql的返回值，尽量使用覆盖索引，如果字段的区分度不高的话，我们也会把它放在组合索引后面的字段。例如like模糊匹配等。
>
> 如果某一个字段的内容较长，我们会考虑使用前缀索引来使用，当然并不是所有的字段都要添加索引，这个索引的数量也要控制，因为添加索引也会导致新增改的速度变慢。
>
> 利用最左前缀原则，将频繁的列放在联合索引的左侧，增加联合索引的使用率。



MySQL 8. 0 索引新特性

> 支持降序索引，好处？
>
> 支持隐藏索引，用途？（用于验证删除索引后对数据库效率的影响）想删除或者想添加索引的时候可以使用



什么情况下索引会失效 ?

> - 索引在使用的时候没有遵循最左匹配法则
> - 模糊查询
> - 如果使用了复合索引，中间使用了范围查询，右边的条件索引也会失效
> - 使用函数，计算或者出现了类型转换。
> - 不等于，非空（索引只能查知道的东西）



sql的优化的经验

> 建表的时候、使用索引、sql语句的编写、主从复制，读写分离，还有一个是如果量比较大的话，可以考虑分库分表



创建表的时候，你们是如何优化的呢？

> 在定义字段的时候需要结合字段的内容来选择合适的类型，如果是数值的话，像tinyint、int 、bigint这些类型，要根据实际情况选择。如果是字符串类型，也是结合存储的内容来选择char和varchar或者text类型



你平时对sql语句做了哪些优化呢？

> - SELECT语句务必指明字段名称
> - 要注意SQL语句避免造成索引失效的写法
> - 如果是表关联的话，尽量使用innerjoin ，不要使用用left join right join，如必须使用 一定要以小表为驱动



索引下推是什么？



普通索引 VS 唯一索引

> 普通索引没有唯一性，唯一索引有唯一性。所以普通索引可能会比唯一索引多查询几个，性能差距较小。
>
> 但是唯一索引不能用change buffer。change buffer是可以将目前不在内存中的页，但需要改变该页数据的改变内容存储在缓冲区中，后续需要读入的时候再merge。不过查询后立即更新的情况下，该缓冲区作用也不大。
>
> 所以如果业务允许则优先用普通索引，不过前提是业务正确性。因为唯一索引能保证索引列不重复。



## 三、数据库调优的角度

确定调优问题的方式

> 用户反馈，日志分析，监控，慢日志等等



调优角度

> - DBMS方面：事务处理，安全性，非关系型数据库等等，主要结合业务逻辑
> - 优化表设计：尽量遵循三范式原则。同时查询较多时，反范式也可以通过增加冗余字段提高查询效率。
> - 优化逻辑查询：SQL的查询重写包括了子查询优化、等价谓词重写、视图重写、条件简化、连接消除和嵌套连接消除等。
> - 优化物理查询：重点针对索引（结合上面说过的索引展开）
> - 使用缓存
> - 库级优化：读写分离，数据分片（分库分表）
> - 拆分表：冷热数据分离
> - 增加冗余字段
> - 优化数据类型？？？



- 建立索引
- SQL优化
- 调整配置
- 分库分表



## 四、查询优化

关联查询优化角度

> - 外连接
>   - 尽量给被驱动表加索引，给驱动表加而不给被驱动表加，则用不上索引。
> - 内连接
>   - 谁做被驱动表是由优化器决定的，哪种情况成本小就用哪种。优先让有索引的当被驱动表，如果都有则优先让数据量大的作为被驱动表（小表驱动大表）



子查询优化角度

> 子查询执行效率不高。需要先对内层查询结果建立一个临时表，然后外层再来查询这些临时表。而临时表没有索引，效率低。如果结果集很大，对查询性能的影响也很大。



排序优化角度、分组优化

> - 没有索引则文件排序
> - 有索引时要符合最左前缀原则，并且排序方向相同。
> - 有索引时，如果没有limit，可能会索引失效：优化器认为需要回表，不如直接文件排序；也有可能会不失效：索引覆盖的情况下。如果有limit减少回表的数量，优先用索引。
> - 分组优化和排序优化类似，先排序后分组



EXISTS 和 IN 的区分

> 标准就是小表驱动大表



COUNT(*)与COUNT(具体字段)效率

> 针对不同的引擎有不同的效率。
>
> 如果是innodb，则都需要全表扫描。对于COUNT(具体字段)尽量用二级索引，因为innodb中的聚簇索引记录完整信息，空间大。没有二级索引才会采用主键索引。
>
> 如果是MyISAM，则会记录row_count，对于COUNT（*）时间复杂度为1，另外一种还是需要全表扫描。



最后一句：多使用COMMIT，能够释放资源（锁，日志等空间资源和管理空间资源的花费）。



UUID = 时间+UUID版本（16字节）- 时钟序列（4字节） - MAC地址（12字节）



## 五、事务

事务的特性是什么？可以详细说一下吗？

> ACID，分别指的是：原子性、一致性、隔离性、持久性。



并发事务带来哪些问题？

> 第一是脏读， 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
>
> 第二是不可重复读：比如在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
>
> 第三是幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。



怎么解决这些问题呢？MySQL的默认隔离级别是？

> 解决方案是对事务进行隔离。
>
> MySQL支持四种隔离级别，分别有：
>
> 未提交读，读已提交，可重复读，串行化。



undo log和redo log的区别

> 最大的区别就是两种日志记录的内容不同，一个记录旧值，一个记录新值。
>
> - undo log是逻辑日志，可以逆操作恢复原来的数据。可以用于MVCC，记录读取数据之前的行版本信息。
>
> - redo log日志记录的是数据页的物理变化，服务宕机可用来同步数据。
>
> - undo需要先将旧值记录，再改新值，即先写日志，保证能恢复到原来的样子。数据写到磁盘才能算事务结束。Redo就可以先存储在内存中，等空闲再更新磁盘。
>
> - redo同样需要先写日志，再改新值，保证宕机时没有提交的事务能回滚到最初状态。可以使用缓冲区，降低刷盘频率，而且日志顺序写入磁盘，速度快。关于刷盘频率可以设置，提交不刷盘，提交刷盘，或者刷盘决定权交给操作系统。只要事务提交成功，redo日志就一定记录在硬盘里，保证数据不会丢失。由`重做日志的缓冲 (redo log buffer)`和`重做日志文件(redologfile)`组成。日志文件组是由一组日志文件组成的，逻辑上写入这些文件的顺序是循环的，使用两个指针记录磁盘更新位置和日志更新位置。
> - undo恢复代价大，内存代价小。不容易出错的系统更倾向于用undo。
> - redo恢复代价小，内存代价大。容易出错的系统更倾向于用redo。



undo-redo日志

> 结合undo-redo日志，做回滚操作时先undo再redo，防止undo把redo的最新数据覆盖。



bin-log日志是什么？用于什么情景？

> 二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。它以`事件形式`记录并保存在`二进制文件`中。通过这些信息，我们可以再现数据更新操作的全过程。
>
> 可以用于数据恢复和数据复制（主从）。



二进制日志(binlog)的写入机制

> 事务执行时，先将日志写到binlog cache中，事务提交时再将binlogcache写入binlog中。为了确保事务的一次性写入，需要给每个线程分配一个块内存作为binlog cache。
>
> binlog cache的刷盘策略：写入时间由系统决定，每次提交都写入，或者是有N次提交写入。



binlog VS redolog

> redo是物理日志，记录了更新的内容。
>
> binlog是逻辑日志，记录的是语句的原始逻辑。
>
> 二者都是为了实现持久化，但侧重点不同，redo主要是崩溃恢复，binlog主要是保持数据库集群的数据一致性。



redo log与binlog两份日志之间的逻辑不一致，会出现什么问题？（具体情景为redo日志完成，但是binlog未完成写入时宕机了）

> 采用两阶段提交方案。针对redolog的写入使用两个阶段。
>
> 在binlog写入之前redolog写入结果为prepare阶段，在binlog写入之后redolog写入结果为commit。这种情况下，如果binlog未能提交，可以将redolog中处于prepare阶段的事务回滚。如果在redocommit时发生错误，并不会回滚，因为binlog已经完成说明事务做完了，可以继续提交事务恢复数据。
>
> ![image-20240316213836710](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240316213836710.png)



中继日志是什么？

> 用于主从架构。为了保持主服务器和从服务器的一致性，需要从主服务器读取二进制日志的内容，将读取到的日志信息写入本地的日志文件中，这个日志就叫做中继日志。默认位于从服务器的数据目录下。



事务中的隔离性是如何保证的呢？（解决并发问题）（见六、七）



## 六、并发问题——锁

什么时候会发生并发问题？怎么解决？

> 读读不发生，写写，读写，写读都可能会发生。会发生脏写，脏读、不可重复读、幻读等问题。即事务隔离性无法保证的几种情况。
>
> 解决方式：锁，MVCC。



说一说读锁，写锁（即共享锁，排他锁）

> 共享锁可以多个读，排他锁只能一个写。



说一说表锁、页锁、行锁

> - 表锁
>   - 表级别的读锁写锁：降低并发能力。MyISAM在增删改时会加，InnoDB不会。
>   - 意向锁：强制性没有读写锁那么强，和行级的共享锁排他锁不互斥。保证并发性，也满足事务隔离性。
>   - 自增锁：针对表中某些列的自增操作。AUTO-INC锁同时只能有一个事务持有，事务之间需要竞争。有三种模式：
>     - 传统模式：有插入操作就需要获得锁
>     - 连续模式：能提前确定插入数据量，就不需要获得锁，如果无法提前确定插入数据量，比如需要根据select的结果决定插入的数据，则还是需要获得锁。
>     - 交叉模式：所有类INSERT语句都不会使用表级AUTO-INC锁，并且可以同时执行多个语句。可以保证所有都是自动递增值，但不保证对同一个事务值是连续的。缺陷就是无法重放，主从复制如果使用的是记录语句，则从机产生的结果和主机可能不同。所以将binlog的级别从statement变为row。
> - 页锁
> - 行锁
>   - MySQL服务器层并没有实现行锁机制，行级锁只在存储引擎层实现。InnoDB与MylSAM的最大不同有两点：一是支持事务(TRANSACTION)；二是采用了行级锁。
>   - 优点（并发度），缺点（锁开销）
>   - 记录锁：将一条记录锁上，分读锁，写锁。
>   - 间隙锁：为了防止插入幻影记录而提出的，是指在指定记录之前不能插入记录。
>   - 临键锁：即记录锁+间隙锁。
>   - 插入意向锁：不是意向锁。**InnoDB规定事务在等待的时候也需要在内存中生成一个锁结构** ，表明有事务想在某个`间隙`中`插入`新记录，但是现在在等待。并不会阻止别的事务继续获取该记录上任何类型的锁。



说一说乐观锁、悲观锁

> - 悲观锁：保守态度，<font color='red'>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程 </font>。应用：Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。
> - 乐观锁：乐观看待，不用每次都对数据上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。实现方式：版本号机制，CAS机制。多用于多读的类型。



说一说全局锁

> 对整个数据库加锁，一般用在全库逻辑备份。



说一说死锁

> 两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环。
>
> 两种解决策略
>
> - 直接等待，等到超时释放
> - 死锁检测，检测到回滚处理。



## 七、并发问题——MVCC

什么是MVCC

> MVCC 是通过数据行的多个版本管理来实现数据库的`并发控制`。解决了InnoDB的事务隔离级别下执行`一致性读`操作。MySQL的InnoDB存储引擎支持MVCC，MySQL的其他引擎不支持。
>
> MVCC 可以不采用锁机制，而是通过乐观锁的方式来解决不可重复读和幻读问题。它可以在大多数情况下替代行级锁，降低系统的开销。



什么是快照读，什么是当前读

> 快照读又叫一致性读，读取的是快照数据。简单来说就是不加锁读，因此读到的内容可能不是最新版本。隔离级别是串行级别的情况下，快照读会退化成当前读。使用的是乐观锁思想。
>
> 当前读是读取记录的最新版本数据，读取时需要保证其他并发事务不能修改当前记录，需要加锁，使用的是悲观锁的思想。



MVCC实现原理是什么？ReadView

> MVCC的实现依赖于隐藏字段，UndoLog，ReadView。
>
> 在MVCC机制中，多个事务对同一个行记录进行更新会产生多个历史快照，这些历史快照保存在Undo Log里，这些不同的历史记录会由隐藏字段区分。如果一个事务想要查询这个行记录，则会用到ReadView。



先不看了，Part16



## 八、分库分表

MySQL主从同步原理 

> - 主库提交事务时，将数据变更记录记录在二进制日志文件binlog中
> - 从库读取主库的binlog，写入到从库的中继日志。
> - 从库重做中继日志中的事件，将改变反映它自己的数据



主从库的数据一致性问题

> 有几种复制方式
>
> - 异步复制：主机做完工作，向从机发送同步操作，同时将成功信息返回给用户。可能会有不一致情况出现。
> - 半同步复制：和异步复制不同的是，有一个从机返回ACK时，将成功信息返回给用户。
> - 组复制：组里大多数ACK才将成功信息返回给用户。



你们项目用过MySQL的分库分表吗？

> - 分库
>   - 垂直：将不同的微服务涉及到的表分开存储在不同的数据库（依据：业务）
>   - 水平：一个库的数据拆分到不同的库中，类似于redis的哈希槽分区。（解决了单库大数量，高并发的性能瓶颈问题）
> - 分表
>   - 垂直：以字段为依据，根据字段属性将不同字段拆分到不同的表中。比如将不常用的或者大字段的字段拆分出来放在附表中。（冷热数据分离）
>   - 水平：将一个表的数据拆分到多个表中（可以在同一个库内）（优化单一表数据量过大而产生的性能问题）
> - 可能会出现的问题
>   - 分布式事务一致性
>   - 跨节点关联查询
>   - 跨节点分页、排序函数
>   - 主键避重
> - 可以用中间件，比如mycat
