## 一、设计模式六大原则

- 开闭原则
- 里氏代换原则
- 依赖倒转原则
- 接口隔离原则
- 迪米特法则
- 合成复用原则



## 二、创建型模式

#### 1. 单例模式

- 饿汉式
  - 不合适的地方：一开始就会创建该实例，但是如果不使用就浪费了。
- 懒汉式
- 双重检测锁
  - 针对懒汉式的线程安全处理，加锁，防止创建多个实例
  - 还要使用volatile禁止指令重排
- 静态内部类
  - 第一次调用获取实例时才会生成单例对象
- 枚举单例



#### 2. 如何解决反射爆破单例

私有化构造方法，实例化之前判断是否已经有该实例，防止外部通过new关键字实例化。提供一个获取实例的静态方法。在单例类中提供readResolve方法，防止序列化和反序列化获取实例。



#### 3. 框架中有关单例的设计

- Spring的Bean对象默认是单例模式
- 工厂对象
- 保存相关配置信息的
- 应用程序的日志
- 数据库连接池的设计



#### 2. 工厂模式

简单工厂：用来生产同一等级结构中的产品，不符合开闭原则

工厂方法：用来生产同一等级结构中的产品，能扩展

抽象工厂：用来生产不同产品族的全部产品



#### 3. 建造者模式

- 针对复杂结构的对象的创建（接收配置，创建对象）。

- 和工厂模式的区别：关注维度不同
  - 工厂模式：更关注于同一类产品的抽象。
  - 建造者模式：关注创建对象本身。



#### 4. 原型模式（克隆模式）

- 针对批量对象的创建
- 浅克隆、深克隆



#### 5. 对创建型模式的理解

- 单例：保证一个对象
- 简单工厂：一个工厂创建不同的对象
- 方法工厂：便于扩展
- 抽象工厂：不同产品族，组装
- 建造者模式：对复杂对象的创建
- 原型模式：批量对象的创建



## 二、结构性模式

#### 1. 代理模式

通过代理对象增强目标对象，让目标对象专注于自己的业务。利用的是AOP切面编程思想。

- 静态代理
- 动态代理
  - JDK动态代理
    - 使用Proxy类的newProxyInstance
  - CGLIB动态代理



#### 2. 适配器模式

将两个不兼容的对象通过适配器能连接起来工作。

应用：



#### 3. 装饰器模式

动态的为一个对象增加新的功能。使用对象的关联关系代替继承关系。

应用：



#### 4. 组合模式、门面模式、桥接模式、享元模式

- 组合模式：解决对象和对象之间的包含关系，部分-整体的层次结构。
- 门面模式：隐藏系统的复杂性，向客户端提供访问系统的接口。
- 桥接模式：代替多层继承问题，提高系统的扩展性
- 享元模式：有很多个完全相同或相似的对象，为了节省内存，可共享内部状态，但是不能共享外部状态。



## 三、行为性模式

主要涉及对象和算法之间职责的分配。

类行为模式包括

- 解释器模式
- 模板模式

对象行为模式

- 责任链模式
- 观察者模式
- 策略模式
- 访问者模式
- 状态模式
- 迭代器模式
- 命令模式
- 备忘录模式
- 中介者模式

#### 1. 解释器模式

解析各种表达式，比如针对SPEL表达式做的解析处理。



#### 2. 模板模式

父类中固定程序的执行顺序，子类中做出具体实现。

比如Spring中的JdbcTemplate。



#### 3. 责任链模式

将能够处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否有能力处理，不能处理，则传给下一个对象处理。

比如处理请求的过滤器链。



#### 4. 观察者模式

建立对象与对象之间的依赖关系，一个对象发生改变时自动通知其他对象。



#### 5. 策略模式

将解决问题的多个实现方式都称为一种策略。



#### 6. 迭代器模式

在客户访问和聚合类之间插入一个迭代器，将聚合对象和遍历方法解耦，并且对外隐藏细节。



#### 7. 中介者模式

对象之间具有很强的关联性，并且有大量的互相调用，如果一个对象发生变化，需要追踪该对象关联的其他对象，并且需要相应的处理，很麻烦。比如MVC中的C。



#### 8. 状态模式、命令模式、备忘录模式、访问者模式



