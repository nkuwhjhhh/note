## 一、线程基础知识

进程与线程的区别

> - 进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务
> - 不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间
> - 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低(上下文切换指的是从一个线程切换到另一个线程)



并行和并发有什么区别

> - 针对单核CPU，线程轮流使用CPU，称为并发。
> - 当有多核CPU时，不同线程同时占用不同CPU，称为并行。
>
> 并发（concurrent）是同一时间应对（dealing with）多件事情的能力
>
> 并行（parallel）是同一时间动手做（doing）多件事情的能力



创建线程的四种方式

> 有四种方式：继承Thread类、实现runnable接口、实现Callable接口、线程池创建线程
>
> - 继承Thread类：在继承类中重写run方法，该继承类的实例执行start方法即可启动线程。
> - 实现runnable接口：在实现类中重写run方法，根据该继承类的实例创建Thread对象，Thread对象执行start方法即可启动线程。
> - 实现Callable接口：有返回值的线程。在实现类中重写call方法，创建该实现类的对象，根据该对象创建FutureTask对象并指定返回值类型，根据FutureTask对象创建Thread对象，调用start方法启动线程。其结果可以对FutureTask对象调用get方法获得。
> - 线程池创建线程



runnable 和 callable 有什么区别

> 1. 返回值角度：Runnable 接口run方法没有返回值；Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
> 2. 获得返回值阻塞角度：Callalbe接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执行，如果不调用不会阻塞。
> 3. 抛出异常角度：Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛



线程的 run()和 start()有什么区别？

> start(): 用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。
>
> run(): 封装了要被线程执行的代码，可以被调用多次。会当成一个普通方法被调用。



线程包括哪些状态，状态之间是如何变化的

> - 新建 NEW：尚未启动的线程的线程状态
> - 可运行 RUNNABLE：可运行线程的线程状态。处于可运行状态的线程正在 Java 虚拟机中执行，但它可能正在等待来自操作系统的其他资源，例如处理器。
> - 阻塞 BLOCKED：线程阻塞等待监视器锁的线程状态。处于阻塞状态的线程正在等待监视器锁进入同步块/方法或在调用Object.wait后重新进入同步块/方法。
> - 等待 WAITING
> - 有时限等待 TIMED_WAITING
> - 终结 TERMINATED
>
> ![image-20240526234235499](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240526234235499.png)



新建 T1、T2、T3 三个线程，如何保证它们按顺序执行？

> 调用join方法，在启动T2时，加入T1的join方法，T1执行结束才会执行T2。在启动T3时，加入T2的join方法，T2执行结束才会执行T3。



notify()和 notifyAll()有什么区别？

> notifyAll：唤醒所有wait的线程
>
> notify：只随机唤醒一个 wait 线程



在 java 中 wait 和 sleep 方法的不同？

> 共同点
>
> * wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态
>
> 不同点
>
> * 方法归属不同
>   * sleep(long) 是 Thread 的静态方法
>   * 而 wait()，wait(long) 都是 Object 的成员方法，每个对象都有
> * 醒来时机不同
>   * 执行 sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来
>   * wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去
>   * 它们都可以被打断唤醒
> * ==锁特性不同（重点）==
>   * wait 方法的调用必须先获取 wait 对象的锁，而 sleep 则无此限制
>   * wait 方法必须要在 synchronized 代码块中执行，执行后会释放对象锁，允许其它线程获得该对象锁（我放弃 cpu，但你们还可以用）
>   * 而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁（我放弃 cpu，你们也用不了）



如何停止一个正在运行的线程？

> 有三种方式可以停止线程
>
> - 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。要注意的是退出标志要用volatile修饰。
> - 使用stop方法强行终止（不推荐，方法已作废）
> - 使用interrupt方法中断线程
>   - 打断阻塞线程会抛出interruptedException异常



## 二、线程中并发安全

讲一下synchronized关键字的底层原理？

> Synchronized【对象锁】采用互斥的方式让同一时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。
>
> 在class字节码中的体现是由jvm提供的Monitor监视器，monitorenter 上锁开始的地方，monitorexit 解锁的地方。（monitorexit可能会出现两次，除了正常释放，也要让异常处理时释放。）
>
> 在使用了synchornized代码块时需要指定一个对象，所以synchornized也被称为对象锁。monitor主要就是跟这个对象产生关联。
>
> Monitor内部具体的存储结构有三个结构组成：Owner，EntryList，WaitSet。
>
> - Owner：存储当前获取锁的线程的，只能有一个线程可以获取
>
> - EntryList：关联没有抢到锁的线程，处于Blocked状态的线程
>
> - WaitSet：关联调用了wait方法的线程，处于Waiting状态的线程
>
> 其具体流程为：
>
> - 代码进入synchorized代码块，先让lock（对象锁）关联的monitor，然后判断Owner是否有线程持有
> - 如果没有线程持有，则让当前线程持有，表示该线程获取锁成功
> - 如果有线程持有，则让当前线程进入entryList进行阻塞，如果Owner持有的线程已经释放了锁，在EntryList中的线程去竞争锁的持有权（非公平）
> - 如果代码块中调用了wait()方法，则会进去WaitSet中进行等待。



什么是重量级锁，偏向锁，轻量级锁

> - Monitor实现的锁属于重量级锁，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。
>
> - 在JDK 1.6引入了两种新型锁机制：偏向锁和轻量级锁，它们的引入是为了解决在没有多线程竞争或基本没有竞争的场景下因使用传统锁机制带来的性能开销问题。



对象的内存结构

> 在HotSpot虚拟机中，对象在内存中存储的布局可分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐填充
>
> 其中对象头又由MarkWord对象头和Klass Word描述对象实例的具体类型组成。
>
> - MarkWord对象头：能标记状态，一共五种：无锁，偏向锁，轻量级锁，重量级锁，标记为GC。
> - ![image-20240527200156364](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240527200156364.png) 
> - 我们可以通过lock的标识，来判断是哪一种锁的等级
>
>   - 后三位是001表示无锁
>   - 后三位是101表示偏向锁
>   - 后两位是00表示轻量级锁
>   - 后两位是10表示重量级锁



再说Monitor重量级锁、轻量级锁、偏向锁

> ==重量级锁==
>
> 每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（重量级）之后，**该对象头的Mark Word 中就被设置指向 Monitor 对象的指针**。
>
> ==轻量级锁==
>
> 但是很多情况下，同步块代码是不存在竞争的，不同的线程交替的执行同步块中的代码。所以可以使用轻量级锁。轻量级锁的底层使用的是CAS技术。
>
> **加锁流程**如下：
>
> 1. 在线程栈中创建一个Lock Record，将其obj字段指向锁对象。
> 2. 通过CAS指令将Lock Record的地址存储在对象头的mark word中（数据进行交换），如果对象处于无锁状态则修改成功，代表该线程获得了轻量级锁。
> 3. 如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。
> 4. 如果CAS修改失败，说明发生了竞争，需要膨胀为重量级锁。
>
> 解锁流程和加锁流程刚好相反。
>
> ==偏向锁==
>
> 省去了轻量级锁每次重入时都要做的CAS操作。在对象中存储的是线程id。
>
> 加锁流程如下：
>
> 1. 在线程栈中创建一个Lock Record，将其obj字段指向锁对象。
> 2. 通过CAS指令将Lock Record的**线程id**存储在对象头的mark word中，同时也设置偏向锁的标识为101，如果对象处于无锁状态则修改成功，代表该线程获得了偏向锁。
> 3. 如果是当前线程已经持有该锁了，代表这是一次锁重入。设置Lock Record第一部分为null，起到了一个重入计数器的作用。与轻量级锁不同的时，这里不会再次进行cas操作，只是判断对象头中的线程id是否是自己，因为缺少了cas操作，性能相对轻量级锁更好一些。
>
> 解锁流程相反。



Monitor实现的锁属于重量级锁，你了解过所升级吗？

> |          | **描述**                                                     |
> | -------- | ------------------------------------------------------------ |
> | 重量级锁 | 底层使用的Monitor实现，里面涉及到了用户态和内核态的切换、进程的上下文切换，成本较高，性能比较低。 |
> | 轻量级锁 | 线程加锁的时间是错开的（也就是没有竞争），可以使用轻量级锁来优化。轻量级修改了对象头的锁标志，相对重量级锁性能提升很多。每次修改都是CAS操作，保证原子性 |
> | 偏向锁   | 一段很长的时间内都只被一个线程使用锁，可以使用了偏向锁，在第一次获得锁时，会有一个CAS操作，之后该线程再获取锁，只需要判断mark  word中是否是自己的线程id即可，而不是开销相对较大的CAS命令 |
>
> **一旦锁发生了竞争，都会升级为重量级锁**



你谈谈 JMM（Java 内存模型）

> JMM是Java内存模型，描述了Java程序中各种变量(线程共享变量)的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。
>
> ![image-20240527202108298](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240527202108298.png)
>
> 特点：
>
> 1. 所有的共享变量都存储于主内存(计算机的RAM)这里所说的变量指的是实例变量和类变量。不包含局部变量，因为局部变量是线程私有的，因此不存在竞争问题。
>
> 2. 每一个线程还存在自己的工作内存，线程的工作内存，保留了被线程使用的变量的工作副本。
> 3. 线程对变量的所有的操作(读，写)都必须在工作内存中完成，而不能直接读写主内存中的变量，不同线程之间也不能直接访问对方工作内存中的变量，线程间变量的值的传递需要通过主内存完成。



CAS 你知道吗？

> 它体现的一种乐观锁的思想，在无锁情况下保证线程操作共享数据的原子性。
>
> 在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作
>
> - AbstractQueuedSynchronizer（AQS框架）
>
> - AtomicXXX类
>
> 一个当前内存值V、旧的预期值A、即将更新的值B，当且仅当旧的预期值A和内存值V相同时，将内存值修改为B并返回true，否则什么都不做，并返回false。如果CAS操作失败，通过自旋的方式等待并再次尝试，直到成功。其中自旋操作是一个while循环，需要不断尝试获取共享内存V中最新的值，然后再在新的值的基础上进行更新操作，如果失败就继续尝试获取新的值，直到更新成功。
>
> 
>
> 其底层实现是依赖于Unsave类直接调用操作系统底层的CAS指令，该类下的方法都是native修饰的方法，由系统提供的接口执行，并非java代码实现。
>
> 可能会有ABA问题。



请谈谈你对 volatile 的理解

> 两层含义：一是保证线程间的可见性，二是禁止进行指令的重排序。
>
> - 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的,volatile关键字会强制将修改的值立即写入主存。
> - 用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果。写操作加的屏障是阻止上方其它写操作越过屏障排到volatile变量写之下；读操作加的屏障是阻止下方其它读操作越过屏障排到volatile变量读之上。“先读后写”
> - 使用技巧：
>   - 写变量让volatile修饰的变量的在代码最后位置
>   - 读变量让volatile修饰的变量的在代码最开始位置



什么是AQS？

> 全称是 AbstractQueuedSynchronizer 抽象队列同步器，是阻塞式锁和相关的同步器工具的框架，它是构建锁或者其他同步组件的基础框架。
>
> AQS与Synchronized的区别
>
> | **synchronized**               | **AQS**                                |
> | ------------------------------ | -------------------------------------- |
> | 关键字，c++ 语言实现           | java  语言实现                         |
> | 悲观锁，自动释放锁             | 悲观锁，手动开启和关闭                 |
> | 锁竞争激烈都是重量级锁，性能差 | 锁竞争激烈的情况下，提供了多种解决方案 |
>
> AQS常见的实现类
>
> - ReentrantLock        阻塞式锁
>
> - Semaphore             信号量
>
> - CountDownLatch   倒计时锁
>
> 工作机制
>
> - AQS中维护了一个使用了volatile修饰的state属性来表示资源的状态，0表示无锁，1表示有锁。
> - 提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList
> - 条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet
>
> 同时又多个线程抢资源，如何保证原子性？
>
> 在去修改state状态的时候，使用的cas自旋锁来保证原子性，确保只能有一个线程修改成功，修改失败的线程将会进入FIFO队列中等待。
>
> AQS是公平锁吗，还是非公平锁？
>
> - 新的线程与队列中的线程共同来抢资源，是非公平锁
>
> - 新的线程到队列中等待，只让队列中的head线程获取锁，是公平锁



ReentrantLock的实现原理

> ReentrantLock是可重入锁，可中断，可以设置超时时间，可以设置公平锁，支持多个条件变量，与synchronized一样都支持重入。
>
> ReentrantLock主要利用CAS+AQS队列来实现。它支持公平锁和非公平锁，两者的实现类似。
>
> 构造方法接受一个可选的公平参数（默认非公平锁），当设置为true时，表示公平锁，否则为非公平锁。公平锁的效率往往没有非公平锁的效率高，在许多线程访问的情况下，公平锁表现出较低的吞吐量。
>
> 工作流程如下
>
> ![image-20240527215137979](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240527215137979.png)
>
> - 线程来抢锁后使用cas的方式修改state状态，修改状态成功为1，则让exclusiveOwnerThread属性指向当前线程，获取锁成功
>
> - 假如修改状态失败，则会进入双向队列中等待，head指向双向队列头部，tail指向双向队列尾部
>
> - 当exclusiveOwnerThread为null的时候，则会唤醒在双向队列中等待的线程
>
> - 公平锁则体现在按照先后顺序获取锁，非公平体现在不在排队的线程也可以抢锁



synchronized和Lock有什么区别 ? 

> * 语法层面
>   * synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现
>   * Lock 是接口，源码由 jdk 提供，用 java 语言实现
>   * 使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁
> * 功能层面
>   * 二者均属于悲观锁、都具备基本的互斥、同步、锁重入功能
>   * Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态、公平锁、可打断、可超时、多条件变量
>   * Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock
> * 性能层面
>   * 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖
>   * 在竞争激烈时，Lock 的实现通常会提供更好的性能



死锁产生的条件是什么？



如何进行死锁诊断？

> 当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack
>
> 使用jps查看运行的线程，会显示线程的情况，使用jstack可以查看某个线程的运行情况。
>
> 还有其他的工具：jconsole，VisualVM等。



ConcurrentHashMap

> 分别说1.7和1.8的两个实现即可。（还是数组+链表变为 数组+链表或红黑树）主要说一下segment数组，node。



导致并发程序出现问题的根本原因是什么

> Java并发编程三大特性：原子性，可见性，有序性
>
> - 原子性是指一个线程在CPU中操作不可暂停，也不可中断，要不执行完成，要不不执行。
> - 内存可见性：让一个线程对共享变量的修改对另一个线程可见。
> - 有序性：java中用到了指令重排，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的
> - 针对原子性解决方式：synchronized，LOCK
> - 针对内存可见性解决方式：synchronized，volatile，LOCK
> - 针对有序性：volatile



## 三、线程池

为什么要使用线程池？



说一下线程池的核心参数（线程池的执行原理知道嘛）

> 线程池核心参数主要参考ThreadPoolExecutor这个类的7个参数的构造函数
>
> - corePoolSize 核心线程数目
> - maximumPoolSize 最大线程数目 = (核心线程+空闲线程的最大数目)
>
> - keepAliveTime 生存时间 - 空闲线程的生存时间，生存时间内没有新任务，此线程资源会释放
>
> - unit 时间单位 - 空闲线程的生存时间单位，如秒、毫秒等
>
> - workQueue - 当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建空闲线程执行任务
>
> - threadFactory 线程工厂 - 可以定制线程对象的创建，例如设置线程名字、是否是守护线程等
>
> - handler 拒绝策略 - 当所有线程都在繁忙，workQueue 也放满时，会触发拒绝策略
>
> **工作流程**
>
> ![image-20240527224328088](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240527224328088.png)
>
> 拒绝策略
>
> - AbortPolicy：直接抛出异常，默认策略
> - CallerRunsPolicy：用调用者所在的线程来执行任务
> - DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务
> - DiscardPolicy：直接丢弃任务



线程池中有哪些常见的阻塞队列

> 阻塞队列：当没有空闲核心线程时，新来任务会加入到此队列排队，队列满会创建空闲线程执行任务。
>
> 1.ArrayBlockingQueue：基于数组结构的有界阻塞队列，FIFO。
>
> 2.LinkedBlockingQueue：基于链表结构的有界阻塞队列，FIFO。
>
> 3.DelayedWorkQueue ：是一个优先级队列，它可以保证每次出队的任务都是当前队列中执行时间最靠前的
>
> 4.SynchronousQueue：不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。
>
> **ArrayBlockingQueue的LinkedBlockingQueue区别**
>
> | **LinkedBlockingQueue**          | **ArrayBlockingQueue** |
> | -------------------------------- | ---------------------- |
> | 默认无界，支持有界               | 强制有界               |
> | 底层是链表                       | 底层是数组             |
> | 是懒惰的，创建节点的时候添加数据 | 提前初始化 Node  数组  |
> | 入队会生成新 Node                | Node需要是提前创建好的 |
> | 两把锁（头尾）                   | 一把锁                 |
>



如何确定核心线程数（从并发和任务执行时间两个角度考虑）

> 分IO密集和CPU密集
>
> - IO密集型任务
>
> 一般来说：文件读写、DB读写、网络请求等
>
> 推荐：核心线程数大小设置为2N+1    （N为计算机的CPU核数）
>
> - CPU密集型任务
>
> 一般来说：计算型代码、Bitmap转换、Gson转换等
>
> 推荐：核心线程数大小设置为N+1    （N为计算机的CPU核数）
>
> 回答：
>
> ① 高并发、任务执行时间短 -->（ CPU核数+1 ），减少线程上下文的切换
>
> ② 并发不高、任务执行时间长
>
> - IO密集型的任务 --> (CPU核数 * 2 + 1)
>
> - 计算密集型任务 --> （ CPU核数+1 ）
>
> ③ 并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）



线程池的种类有哪些

> 常见的有四种：固定线程数的线程池，单线程化的线程池，可缓存线程池，提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。
>
> - 固定线程数的线程池
>   - 核心线程数与最大线程数一样，没有救急线程
>   - 阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE
>
>   - 适用场景：适用于任务量已知，相对耗时的任务
> - 单线程化的线程池
>   - 它只会用唯一的工作线程来执行任 务，保证所有任务按照指定顺序(FIFO)执行
>   - 核心线程数和最大线程数都是1
>   - 阻塞队列是LinkedBlockingQueue，最大容量为Integer.MAX_VALUE
>
>   - 适用场景：适用于按照顺序执行的任务
> - 可缓存线程池
>   - 核心线程数为0
>   - 最大线程数是Integer.MAX_VALUE
>
>   - 阻塞队列为SynchronousQueue:不存储元素的阻塞队列，每个插入操作都必须等待一个移出操作。
>
>   - 适用场景：适合任务数比较密集，但每个任务执行时间较短的情况
> - 提供了“延迟”和“周期执行”功能的ThreadPoolExecutor。
>   - 适用场景：有定时和延迟执行的任务



为什么不建议用Executors创建线程池

> 可能会堆积大量请求，导致OOM。



## 四、使用场景

线程池使用场景CountDownLatch、Future（你们项目哪里用到了多线程）

> CountDownLatch（闭锁/倒计时锁）用来进行线程同步协作，等待所有线程完成倒计时（一个或者多个线程，等待其他多个线程完成某件事情之后才能执行）。
>
> - 其中构造参数用来初始化等待计数值
>
> - await() 用来等待计数归零
>
> - countDown() 用来让计数减一
>
> 使用CountDownLatch的案例
>
> - 数据汇总
>   - 在一个电商网站中，用户下单之后，需要查询数据，数据包含了三部分：订单信息、包含的商品、物流信息；这三块信息都在不同的微服务中进行实现的，我们如何完成这个业务呢？
>   - 如果串行执行，则耗时是所有时间加在一起；这里使用了线程池和future，此时时长就是由最长的业务那个决定。
> - 异步调用
>   - 搜索历史和搜索功能本身（就是说下级方法不能影响上级方法）



如何控制某个方法允许并发访问线程的数量？

> 使用Semaphore信号量
>
> lsemaphore.acquire()： 请求一个信号量，这时候的信号量个数-1（一旦没有可使用的信号量，也即信号量个数变为负数时，再次请求的时候就会阻塞，直到其他线程释放了信号量）
>
> lsemaphore.release()：释放一个信号量，此时信号量个数+1



谈谈你对ThreadLocal的理解

> ThreadLocal是多线程中对于解决线程安全的一个操作类，它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题。ThreadLocal 同时实现了线程内的资源共享。
>
> 有三个主要方法
>
> - set(value) 设置值
> - get() 获取值
>
> - remove() 清除值
>
> ThreadLocal本质来说就是一个线程内部存储类，从而让多个线程只操作自己内部的值，从而实现线程数据隔离。在ThreadLocal中有一个内部类叫做ThreadLocalMap，类似于HashMap。ThreadLocalMap中有一个属性table数组，这个是真正存储数据的位置。



ThreadLocal-内存泄露问题

> Java对象中的四种引用类型：强引用、软引用、弱引用、虚引用。
>
> threadlocal中key为弱引用，value为强引用。key可能会被回收，但是value不会自动回收。当key被回收时，value可能还留在内存中。因此需要手动remove
