## 一、外卖

#### 1.1 登录部分

JWT是什么？由什么组成的？怎么实现的？可以实现单点登录吗？

> 是JSON Web Token（JSON Web令牌），用于在各方之间以JSON对象安全地传输信息。此信息可以验证和信任，因为它是数字签名的。jwt可以使用秘密〈使用HNAC算法）或使用RSA或ECDSA的公钥/私钥对进行签名。
>
> 由三部分组成，Header，Payload，数字签名。头部存储令牌类型，加密方式等信息，payload存储有关实体的信息，一般不存储敏感信息，因为是对明文base64编码的信息，并非加密；数字签名是为了防止消息被篡改，服务端用于校验的信息。
>
> 这里的实现是将用户的不敏感信息存储在jwt中，后端接收到用户请求时，使用AOP技术在响应前解析jwt，接收用户信息，判断用户是否有权限等。再将用户信息存储在threadlocal中，用于后续后端对相应的处理。
>
> 可以实现单点登录，即无状态登录。
>
> - 有状态登录：为了保证客户端cookie的安全性，服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如tomcat中的session。
>   - 缺点：服务端保存大量数据，增加服务端压力；服务端保存用户状态，无法进行水平扩展；客户端请求依赖服务端，多次请求必须访问同一台服务器。
> - 无状态登录：服务端不保存任何客户端请求者信息。客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份。
>   - 好处：客户端请求不依赖服务端的信息，任何多次请求不需要必须访问到同一台服务；服务端的集群和状态对客户端透明；服务端可以任意的迁移和伸缩；减小服务端存储压力。



threadlocal是什么？在此处有什么作用？

> 对应线程中存储的信息，线程之间互不影响。此处用于记录拦截器拦截jwt时解析出的用户信息，用于后续操作。



Redis几种数据类型的底层实现，应用场景

> - String：主要是int和SDS
> - List：快表
> - Hash：压缩列表或者哈希表
> - Set：哈希表或者整数集合
> - Zset：压缩列表或者跳表
>
> 
>
> - String：直接缓存整个对象的json；常规计数；分布式锁；共享Session信息。
> - List：消息队列
> - Hash：缓存对象；购物车
> - Set：（特点：无序，唯一性，求交集并集等）点赞功能；共同关注。
> - Zset：（可排序）排行榜；消息推送。
> - BitMap：用户签到。



## 二、点评

Redis缓存用户信息，解决集群模式下session共享问题

> 该功能分三个过程
>
> - 发送短信验证码
>   - 将验证码存储在Redis中
> - 验证短信验证码
>   - 从redis中取出验证码进行校验，通过验证，则将用户信息存入redis，同时发送token给用户
> - 登录校验状态
>   - 用户带着token登录，从redis中取出用户此次，判断当前用户是否存在，存在则将用户信息存入ThreadLocal，方便之后取用户信息。



双重拦截器是为了解决什么？

> 和上面项目实现的登录功能不同的是，这里还要刷新令牌时间。用户每次请求时都更新时间。使用双重拦截器，如果有token则更新，此处只会对有用户信息的进行更新，没有token的也会放行，同样的，这里对token解析之后还是会将用户信息存储在threadlocal中。
>
> 第二个拦截器主要是权限过滤。针对需要登录后才能登录的页面，检查用户信息，存在则放行。



分布式锁Redisson+Lua脚本解决超卖限购问题，怎么解决的？

> 解决的基本思路：使用setnx获取释放互斥锁。
>
> 问题：互斥锁的释放？极端情况下超时释放导致的错误？如何解决？（释放之前再次判断锁是否为自己的，然后再删除）判断和删除不是原子性的会导致什么结果？怎么解决出现的问题？
>
> 互斥锁采用超时释放，不采用手动释放是因为若出现运行出现错误等，导致锁无法释放，使得其他用户也拿不到锁。
>
> 极端情况下业务运行时间太长可能会导致锁提前释放，解决超卖问题就无法保证。有两种解决方式：用户在释放锁之前需要判断锁是否为自己的，或者使用redisson，有续约机制。
>
> 第一种解决方式有一个问题：不好控制超时释放时间。



Redisson可重入吗？可以设置过期时间吗？拿不到锁时怎么解决？看门狗机制？Lua脚本有原子性吗？Redis有事务原子性吗？

> 可重入，原理是记录锁和使用锁的次数，每次拿到所都需要增加一次使用次数，使用次数为0才可释放。
>
> 可以设置时间。不设置时间则会有默认的时间30s。
>
> 拿不到锁时，会比较自己的过期时间和锁的过期时间之差，如果拿不到则直接返回，若有机会则订阅释放锁的消息，释放锁时去抢，如果一直没能收到释放消息，则取消订阅。
>
> 看门狗机制是为了实现续约机制。其实现是在后台开启一个定时线程，每隔一段时间去续约。
>
> Lua脚本可以保证指令依次执行而不受其他指令干扰，但是不能保证指令最终必定是原子性的。原理是lua脚本会作为一个整体加入redis的队列中，单线程依次执行任务。
>
> Redis不保证事务原子性，只能决定是否开始执行全部指令，没有执行一半后回滚的能力。



消息队列

> - 创建一个消息队列，在判定用户有购买资格后向消息队列中添加消息，启动项目时开启一个线程任务，尝试获取队列中的信息，完成。