## 集群

#### 一、概述

在哨兵中解决了大量读时的压力问题，但是没有解决大量写时的压力问题。集群可以解决这个问题。

> 由于数据量过大，单个Master复制集难以承担，因此需要对多个复制集进行集群，形成水平扩展每个复制集只负责存储整个数据集的一部分，这就是Redis的集群，其作用是提供在多个Redis节点间共享数据的程序集。
>
> ![image-20240421225811838](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421225811838.png)
>
> ![image-20240422214133038](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422214133038.png)



#### 二、作用

![image-20240421230146711](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421230146711.png)



#### 三、集群算法-分片-槽位slot

##### 1. 集群和槽位

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421230315817.png" alt="image-20240421230315817" style="zoom:50%;" /> 

<img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421231417870.png" alt="image-20240421231417870" style="zoom: 50%;" /> 

##### 2. 分片

- 使用Redis集群时我们会将存储的数据分散到多台redis机器上，这称为分片。简言之，集群中的每个Redis实例都被认为是整个数据的一个分片。
- 为了找到给定key的分片，我们对key进行CRC16(key)算法处理并通过对总分片数量取模。然后，使用确定性哈希函数，这意味着给定的key将多次始终映射到同一个分片，我们可以推断将来读取特定key的位置。



直观来看，槽位属于整个redis集群，会分配给不同的分片，分片就是集群中一个master。



##### 3. 优势![image-20240421231736344](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421231736344.png)



##### 4. 槽位映射

- 哈希取余分区
  - <img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421232219436.png" alt="image-20240421232219436" style="zoom:50%;" /> 
  - 缺点
    - 原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)/3会变成Hash(key) /?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。
- 一致性哈希算法分区
  - 提出一致性Hash解决方案。目的是当服务器个数发生变动时，尽量减少影响客户端到服务器的映射关系。
  - <img src="C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421234207480.png" alt="image-20240421234207480" style="zoom: 67%;" /> 
  - 分片IP取哈希，可以获得自己槽位的部分。key取哈希，可以获得自己的落点
  - 优缺点
    - 优点：容错性高，服务器挂了代价小（只影响顺时针到下一个服务器的部分）
    - 缺点：数据倾斜问题，单纯的ip哈希不能保证所有服务器均匀分配，哈希槽分区可以解决这个问题
- 哈希槽分区
  - Redis 集群中内置了 16384 个哈希槽，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点。当需要在 Redis 集群中放置一个 key-value时，redis先对key使用crc16算法算出一个结果然后用结果对16384求余数[ CRC16(key) % 16384]，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，也就是映射到某个节点上。如下代码，key之A 、B在Node2， key之C落在Node3上
  - 自己的理解：在客户端和redis之间加一层，由这一层决定key属于哪个分片。也是用的哈希，只不过这个哈希能够使得key的分布更加均匀，也不会因为某个分片节点要退出时，key重新找自己的分片节点。
  - ![image-20240422202559042](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422202559042.png)




##### 5. 面试题

Redis集群并没有使用一致性hash而是引入了哈希槽的概念。Redis 集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。但为什么哈希槽的数量是16384（2^14）个呢？

CRC16算法产生的hash值有16bit，该算法可以产生2^16=65536个值。换句话说值是分布在0~65535之间，有更大的65536不用为什么只用16384就够？作者在做mod运算的时候，为什么不mod65536，而选择mod16384？ HASH_SLOT = CRC16(key) mod 65536为什么没启用？

解释：

> 正常的心跳数据包带有节点的完整配置，可以用幂等方式用旧的节点替换旧节点，以便更新旧的配置。
>
> ==这里解释一下心跳包：==
>
> ==进入命令传播阶段候，master与slave间需要进行信息交换，使用心跳机制进行维护，实现双方连接保持在线==
>
> - ![image-20240422204833223](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422204833223.png)
> - ![image-20240422204850054](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422204850054.png)
>
> 这意味着它们包含原始节点的插槽配置，该节点使用2k的空间和16k的插槽，但是会使用8k的空间（使用65k的插槽）。
>
> 同时，由于其他设计折衷，Redis集群不太可能扩展到1000个以上的主节点。
>
> 因此16k处于正确的范围内，以确保每个主机具有足够的插槽，最多可容纳1000个矩阵，但数量足够少，可以轻松地将插槽配置作为原始位图传播。请注意，在小型群集中，位图将难以压缩，因为当N较小时，位图将设置的slot / N位占设置位的很大百分比。

> (1)如果槽位为65536，发送心跳信息的消息头达8k，发送的心跳包过于庞大。
>
> 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为65536时，这块的大小是: 65536÷8÷1024=8kb 
>
> 在消息头中最占空间的是myslots[CLUSTER_SLOTS/8]。 当槽位为16384时，这块的大小是: 16384÷8÷1024=2kb 
>
> 因为每秒钟，redis节点需要发送一定数量的ping消息作为心跳包，如果槽位为65536，这个ping消息的消息头太大了，浪费带宽。
>
>  ==也就是说槽位个数和发送心跳消息的消息头大小是成比例的，槽位65536比槽位16384多了4倍的消息头大小==
>
> 
>
> (2)redis的集群主节点数量基本不可能超过1000个。
>
> 集群节点越多，心跳包的消息体内携带的数据越多。如果节点过1000个，也会导致网络拥堵。因此redis作者不建议redis cluster节点数量超过1000个。 那么，对于节点数在1000以内的redis cluster集群，16384个槽位够用了。没有必要拓展到65536个。
>
> 
>
> (3)槽位越小，节点少的情况下，压缩比高，容易传输
>
> Redis主节点的配置信息中它所负责的哈希槽是通过一张bitmap的形式来保存的，在传输过程中会对bitmap进行压缩，但是如果bitmap的填充率slots / N很高的话(N表示节点数)，bitmap的压缩率就很低。 如果节点数很少，而哈希槽数量很多的话，bitmap的压缩率就很低。 



另：

Redis集群不保证强一致性，这意味着在特定的条件下，Redis集群可能会丢掉一些被系统收到的写入请求命令。



#### 四、案例

看讲义

配置三个主机三个从集

![image-20240422210601852](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422210601852.png)

![image-20240422210824694](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422210824694.png)

#### 五、集群常用操作命令和CRC16算法分析

![image-20240422214202012](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240422214202012.png)

数据共享不代表数据存储在一起。而是主从数据一致，不保证集群中所有从集数据一致，因此只要有主机从机一起挂掉，集群中数据就不完整了。对于不完整的集群，可以选择是否继续提供服务。
