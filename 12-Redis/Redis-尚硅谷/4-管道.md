## 管道

#### 一、来源

redis基于C/S模型及TCP服务。请求通常是客户端发送命令，命令排队，命令执行，返回结果，以阻塞模式等待服务器响应。频繁命令往返会造成性能瓶颈。

![image-20240421180339720](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421180339720.png)

如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了RTT（Round Time Trip），而且还频繁调用系统IO，发送网络请求，同时需要redis调用多次read()和write()系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好



#### 二、解决思路

管道(pipeline)可以一次性发送多条命令给服务端，服务端依次处理完完毕后，通过一条响应一次性将结果返回，通过减少客户端与redis的通信次数来实现降低往返延时时间。pipeline实现的原理是队列，先进先出特性就保证数据的顺序性。

![image-20240421180446077](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240421180446077.png)

==仅仅将命令打包一次性发送，对redis的执行不造成其他任何影响。==类似redis原生批命令。



#### 三、pipeline VS 原生批量命令（mset，mget）

- 原生批量命令是原子性，pipeline是非原子性
- 原生批量命令一次只能执行一种命令，pipeline支持批量执行不同命令
- 原生批量命令是服务端实现，而pipeline需要服务端与客户瑞共同完成



#### 四、pipeline VS 事务

- 事务具有原子性（这里有点怪，redis事务应该是不能完全保证原子性的），管道不具有原子性
- 管道一次性将多条命令发送到服务器，事务是条条的发，事务只有在接收到exc命令后才会护行，管道不会
- 执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会



#### 五、注意

- pipeline缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令
- 使用pipeline组装的命令个数不能大多，不然数据量过大客户端部阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存