# Part 9 子查询

![image-20240305130227777](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240305130227777.png)

- 子查询（内查询）在主查询之前一次执行完成。
- 子查询的结果被主查询（外查询）使用 。
- **注意事项**
  - 子查询要包含在括号内
  - 将子查询放在比较条件的右侧
  - 单行操作符对应单行子查询，多行操作符对应多行子查询



### 1. 单行子查询

#### 1.1 单行比较操作符

| 操作符 | 含义                     |
| ------ | ------------------------ |
| =      | equal to                 |
| >      | greater than             |
| >=     | greater than or equal to |
| <      | less than                |
| <=     | less than or equal to    |
| <>     | not equal to             |



#### 1.2 HAVING 中的子查询

- 首先执行子查询。
- 向主查询中的HAVING 子句返回结果。



#### 1.3 CASE中的子查询

在CASE表达式中使用单列子查询。



#### 1.4 子查询中的空值问题

子查询不返回任何行



#### 1.5 非法使用子查询

多行子查询使用单行比较符



#### 2. 多行子查询

- 也称为集合比较子查询
- 内查询返回多行
- 使用多行比较操作符

#### 2.1 多行比较操作符

| 操作符 | 含义                                                         |
| ------ | ------------------------------------------------------------ |
| IN     | 等于列表中的**任意一个**                                     |
| ANY    | 需要和单行比较操作符一起使用，和子查询返回的**某一个**值比较 |
| ALL    | 需要和单行比较操作符一起使用，和子查询返回的**所有**值比较   |
| SOME   | 实际上是ANY的别名，作用相同，一般常使用ANY                   |



### 3. 相关子查询

#### 3.1 相关子查询执行流程

如果子查询的执行依赖于外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就称之为`关联子查询`。

相关子查询按照一行接一行的顺序执行，主查询的每一行都执行一次子查询。

比如：查询员工中工资大于本部门平均工资的员工的last_name,salary和其department_id

![image-20240305191757377](C:\Users\86158\AppData\Roaming\Typora\typora-user-images\image-20240305191757377.png)

#### 3.2 EXISTS 与 NOT EXISTS关键字

- 关联子查询通常也会和 EXISTS操作符一起来使用，用来检查在子查询中是否存在满足条件的行。
- **如果在子查询中不存在满足条件的行：**
  - 条件返回 FALSE
  - 继续在子查询中查找
- **如果在子查询中存在满足条件的行：**
  - 不在子查询中继续查找
  - 条件返回 TRUE
- NOT EXISTS关键字表示如果不存在某种条件，则返回TRUE，否则返回FALSE。

#### 3.3 相关更新

```sql
UPDATE table1 alias1
SET    column = (SELECT expression
                 FROM   table2 alias2
                 WHERE  alias1.column = alias2.column);
```

使用相关子查询依据一个表中的数据更新另一个表的数据。

#### 3.4 相关删除

```sql
DELETE FROM table1 alias1
WHERE column operator (SELECT expression
                        FROM   table2 alias2
                        WHERE  alias1.column = alias2.column);
```

使用相关子查询依据一个表中的数据删除另一个表的数据。

#### 3.5 思考

在许多 DBMS 的处理过程中，对于自连接的处理速度要比子查询快得多。